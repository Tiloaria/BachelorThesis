\documentclass[specification,annotation]{itmo-student-thesis}

\usepackage{fontspec}
\setmainfont[Mapping=tex-text]{CMU Serif}
\setsansfont{CMU Sans Serif}                %% задаёт шрифт без засечек
\setmonofont{CMU Typewriter Text}  

%% Опции пакета:
%% - specification - если есть, генерируется задание, иначе не генерируется
%% - annotation - если есть, генерируется аннотация, иначе не генерируется
%% - times - делает все шрифтом Times New Roman, собирается с помощью xelatex
%% - languages={...} - устанавливает перечень используемых языков. По умолчанию это {english,russian}.
%%                     Последний из языков определяет текст основного документа.

%% Делает запятую в формулах более интеллектуальной, например:
%% $1,5x$ будет читаться как полтора икса, а не один запятая пять иксов.
%% Однако если написать $1, 5x$, то все будет как прежде.
\usepackage{icomma}

%% Один из пакетов, позволяющий делать таблицы на всю ширину текста.
\usepackage{tabularx}

%% Данные пакеты необязательны к использованию в бакалаврских/магистерских
%% Они нужны для иллюстративных целей
%% Начало
\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage{filecontents}
\begin{filecontents}{bachelor-thesis.bib}
	@online{ doerr-doerr-lambda-lambda-self-adjustment-arxiv,
		year        = {2015},
		title       = {Optimal Parameter Choices Through Self-Adjustment: Applying the 1/5-th Rule in
			Discrete Settings},
		author      = {Benjamin Doerr and Carola Doerr},
		url         = {http://arxiv.org/abs/1504.03212},
		year        = {2015},
		langid      = {english}
	}
	
	@inproceedings{ example-english,
		year        = {2015},
		booktitle   = {Proceedings of IEEE Congress on Evolutionary Computation},
		author      = {Maxim Buzdalov and Anatoly Shalyto},
		title       = {Hard Test Generation for Augmenting Path Maximum Flow 
			Algorithms using Genetic Algorithms: Revisited},
		pages       = {2121-2128},
		langid      = {english}
	}
	
	@article{ example-russian,
		author      = {Максим Викторович Буздалов},
		title       = {Генерация тестов для олимпиадных задач по программированию 
			с использованием генетических алгоритмов},
		journal     = {Научно-технический вестник {СПбГУ} {ИТМО}},
		number      = {2(72)},
		year        = {2011},
		pages       = {72-77},
		langid      = {russian}
	}
	
	@article{ unrestricted-jump-evco,
		author      = {Maxim Buzdalov and Benjamin Doerr and Mikhail Kever},
		title       = {The Unrestricted Black-Box Complexity of Jump Functions},
		journal     = {Evolutionary Computation},
		year        = {2016},
		note        = {Accepted for publication},
		langid      = {english}
	}
	
	@book{ bellman,
		author      = {R. E. Bellman},
		title       = {Dynamic Programming},
		address     = {Princeton, NJ},
		publisher   = {Princeton University Press},
		numpages    = {342},
		pagetotal   = {342},
		year        = {1957},
		langid      = {english}
	}
\end{filecontents}
%% Конец

%% Указываем файл с библиографией.
\addbibresource{bachelor-thesis.bib}

\begin{document}
	
	\studygroup{M3437}
	\title{Разработка алгоритмов работы с формальной моделью диалогов, представленных в виде графов}
	\author{Савон Юлия Константиновна}{Савон Ю.К.}
	\supervisor{Ульянцев Владимир Игоревич}{Ульянцев В.И.}{доцент, к.т.н.}{доцент факультета информационных технологий и программирования Университета ИТМО}
	\publishyear{2020}
	%% Дата выдачи задания. Можно не указывать, тогда надо будет заполнить от руки.
	\startdate{01}{сентября}{2019}
	%% Срок сдачи студентом работы. Можно не указывать, тогда надо будет заполнить от руки.
	\finishdate{10}{июня}{2020}
	%% Дата защиты. Можно не указывать, тогда надо будет заполнить от руки.
	\defencedate{25}{июня}{2020}
	
	\addconsultant{Ступаков И.М.}{канд. тех. наук, доцент}
	
	\secretary{Павлова О.Н.}
	
	%% Задание
	%%% Техническое задание и исходные данные к работе
	\technicalspec{Требуется провести исследование и разработать набор алгоритмов для выявления отвлечений в графовой модели для робота-оператора.
		Алгоритм принимает набор диалогов, в размере нескольких тысяч. Предварительно выстроенный граф и кластеризацию для фраз оператора. 
		
		На выходе ожидается получить набор отвлечений и перестроенный граф. В качестве метрики качества будет использоваться сравнение с уже существующими графами, которые создавались вручную.}
	
	%%% Содержание выпускной квалификационной работы (перечень подлежащих разработке вопросов)
	\plannedcontents{Пояснительная записка должна описывать предметную область диалогов представленных в виде графов. Так же формулировать цель и задачу выделения отвлечений, содержать описание алгоритмов их поиска. Должны быть описаны сложности и методы их разрешения, если они возникали. Кроме того должны быть приведены примеры работы алгоритмов и сравнение с существующими решениями. Кроме того пояснительная записка должна содержать описания задач из смежных областей и их то, как эти задачи связны с задачей решаемой в работе.}%TODO добавить какие конкретно смежные области
	
	%%% Исходные материалы и пособия 
	\plannedsources{\begin{enumerate}
			\item Среда разработки Visial Studio Code;
			\item ГОСТ 7.32--2001 <<Система стандартов по информации, библиотечному и издательскому делу. Отчет о научно-исследовательской работе. Структура и правила оформления>>.
	\end{enumerate}}
	
	%%% Цель исследования
	\researchaim{Разработа алгоритма выделяющего отвлечения в диалоге, представленном в виде графа.}
	
	%%% Задачи, решаемые в ВКР
	\researchtargets{\begin{enumerate}
			\item Разработать алгоритмы выделения отвлечий;
			\item Реализовать описанные алгоритмы;
			\item Перестроить граф в соответствии с используемой моделью в компании;
			\item Проанализировать результаты работы алгоритмов;
			\item Интегрировать разработки в инфраструктуру компании.
	\end{enumerate}}
	
	%%% Использование современных пакетов компьютерных программ и технологий
	\addadvancedsoftware{Пакет \texttt{tabularx} для чуть более продвинутых таблиц}{\ref{sec:tables}, Приложения~\ref{sec:app:1}, \ref{sec:app:2}}
	\addadvancedsoftware{Пакет \texttt{biblatex} и программное средство \texttt{biber}}{Список использованных источников}
	
	%%% Краткая характеристика полученных результатов 
	\researchsummary{}
	
	%%% Гранты, полученные при выполнении работы 
	\researchfunding{}%TODO вписать стипендию
	
	%%% Наличие публикаций и выступлений на конференциях по теме выпускной работы
	\researchpublications{По теме этой работы был сделан доклад на Конгрессе Молодых Ученых.
		%\begin{refsection}
		%%Однако покажу, как можно ссылаться на свои публикации из списка литературы:
		%%\nocite{example-english, example-russian}
		%%\printannobibliography
		%\end{refsection}
	}
	
	%% Эта команда генерирует титульный лист и аннотацию.
	\maketitle{Бакалавр}
	
	%% Оглавление
	\tableofcontents
	
	%% Макрос для введения. Совместим со старым стилевиком.
	\startprefacepage
	
	На текущий момент времени всё больший процент работы телефонных операторов автоматизируется. В связи с этим возникает потребность в создании роботов, которые бы не просто начитывали текст, а взаимодействовали с человеком, могли отвечать на его вопросы, записывали бы полученную информацию и в целом, были бы неотличимы от человека.
	
	Поскольку оператор обычно звонит с заданной целью, у него есть некоторый сценарий.
	
	Сценарий диалога с оператором — некоторый алгоритм, предоставленный человеку, который звонит по заданному набору телефонных номеров. Целью сценария обычно является получить или донести до клиента информацию. 
	
	Между скриптом\footnote{Здесь и далее в тексте \textbf{скрипт} и \textbf{сценарий} будут использоваться как синонимы}, который дан оператору, и алгоритмом действий для машины есть большая разница. Человеку достаточно задать набор вопросов и дать информацию о возможных продуктах и услугах; он сам умеет обрабатывать ситуации такие как отвлечение от основных вопросов или переспрашивание. Для графа же, любую реакцию надо прописывать.
	
	Робот-оператор - программа, которая используя сценарий умеет проводить диалог с клиентом, интерпретировать и записывать  информацию полученную от клиента, а так же состояния завершенного разговора. Кроме того робот умеет отвечать на заранее прописанный в скрипте набор вопросов и возвращаться обратно к диалогу.
	
	На данный момент существуют графы для диалогов, но писать их долго, продумать все случаи реакций практически невозможно, поэтому ставится глобальная задача превратить набор диалогов в граф. 
	
	Поскольку количество возможных реакций из каждой вершины может быть бесконечным, то было решено отделить такие подграфы и сделать возможность переходить в них при некоторых условиях из каждой вершины.
	
	В работе будут рассмотрены различные алгоритмы поиска таких отвлечений. А так же рассмотренны варианты улучшения для кластеризации, использующие данные о контексте.
	
	%% Начало содержательной части.
	\chapter{Обзор}
	\section{Описание предметной области}
	Изначальная общая задача стоит следующая: есть диалоги, необходимо восстановить граф и найти отвлечения.
	
	На данный момент кроме восстанавливаемой нами модели есть граф который составляется вручную. В этом графе вершинами являются кластеры фраз робота-оператора, а рёбрами фразы человека. То есть при ответах человека происходит переход в разные новые вершины.
	
	Особенностями данной структуры, которые важно отметить, является то, что помимо обычных переходов существуют так же скрытые переходы, которые по умолчанию могут встретиться в любом месте. В качестве примера можно привести вопрос: "А какую компанию вы представляете". При звонке люди могут задать этот вопрос не сразу.
	
	Для того, чтобы не рассматривать каждый такой случай при переходе из каждой вершины, выделяются $\textbf{отвлечения}$. 
	
	$\textbf{Отвлечение}$ - вопрос, который может быть задан в любом месте диалога. 
	
	В задаче восстанавления будет использоваться несколько другой граф. В нём вершинами будут являться кластеры и фраз оператора, и фраз человека. А ребрами последовательные пары фраз из кластеров в диалоге.
	
	\section{Анализ}
	На вход подаётся набор диалогов по которым нужно получить граф для робота, который бы мог проводить аналогичные диалоги.
	
	Граф, если получать его путём обычной кластеризации операторских фраз, получается очень громоздким. В нём плохо видно структуру, его сложно анализировать.
	
	Поскольку конечной целью является построить автомат аналогичный тому, что работает в продуктовой части команды, то появляется необходимость уметь изучать его руками. 
	
	То есть так же как и в графе создаваемом вручную, появляется необходимость выделить отвлечения. В этом случае его структура становится более удобной для изучения. Его можно использовать как вспомогательный инструмент. 
	
	Такие выделения отвлечений позволяют грамотно обрабатывать сценарии, которых не было в изначальном наборе диалогов. Если такие отвлечения не выделить, то в случае вопроса, не предусмотренного в этом месте робот либо ответит невпопад, либо зависнет.
	
	Необходима хорошая кластеризация текстов, поскольку любой алгоритм выделения отвлечений так или иначе будет опираться на эту кластеризацию. При таких кластеризациях полезно учитывать имеющуюся информацию, то есть фразы до текущей и после.
	
	
	\section{Постановка задачи}
	В связи с описаной выше проблемой громоздкости графа, появляется задача выделить отвлечения, которые могли бы встретиться в любом месте.
	
	В случае, когда диалог проводит оператор такие вопросы нет необходимости расписывать, но роботу нужен чёткий скрипт.
	
	Необходимо выделить отвлечения и перестроить граф таким образом, чтобы он покрывал большее количество диалогов и его было проще анализировать.
	
	\section{Выводы по первой главе}
	Рассмотрена предметная область графовой структуры диалогов. Разобрана структура продуктового графа и структура графа для восстанавливаемой модели. Проведён анализ задачи восстановления графа. Поставлена задача выделения отвлечений. 
	
	\chapter{Теоретическая часть}
	\section{Модель предлагаемого решения}
	Поскольку граф на данном этапе всё ещё перестраивается и информация о произнесенных человеком фразах является полезной, так как содержит в себе контекст. То мы оставляем фразы человека в качестве вершин.
	
	Нужно понимать, что изначально кластеризация проводилась только по фразам оператора. Фразы вершин же были разделены на группы, где для каждой группы совпадала предыдущая и последующая вершины оператора. И уже внутри этих групп бились на некоторые подгруппы.
	
	Рассмотрим два подхода в решении задачи выделения отвлечений:
	
	\begin{itemize}
		\item Первый подход заключается в том, чтобы выделить вершины, в которые идёт много рёбер. Порог считается функцией от количества кластеров на которые бъются фразы оператора.
		
		Мы предполагаем, что поскольку отвлечение встречается в разных местах, то и рёбра будут идти в него из множества различных вершин. Такая гипотеза является хорошей, поскольку в обычном графе в вершину обычно приходит одна или две ветки, в случае же отвлечения их должно быть много, или же оно встречается крайне редко.
		
		\item В качестве другого подхода можно выделить циклы и сказать, что вершина следующая в диалоге за вершиной повторения возможно будет являться началом отвечения.
		
		Здесь мы пользуемся наблюдением, что после отвлечения на стронний вопрос, оператор зачастую повторяет ту же или схожую фразу для возвращения в сценарий. Более того, в графе, который используется в реальном окружении робот-оператор так же повторает аналог той фразы, которую произносил, перед тем, как уйти в отвлечение.
	\end{itemize}
	
	
	\section{Соответствие поставленным требованиям}
	Такие алгоритмы позволят найти для диалогов которые были проведены с роботом отвлечения, сопоставить их с выделенными лингвистами и сопоставить результат.
	
	\chapter{Полученные результаты}
	\section{Реализация}
	Выбираются вершины, в которые входит много ребер. Для значений размеров кластеров в интервале от двенадцати до пятнадцати был выбран параметр три. При увеличении количества кластеров соответственно должен увеличиваться и порог.
	
	Во время тестирования на реальных диалогов человека с человеком была выявлена важная особенность. На работу алгоритма очень сильно влияет качество кластеризации. Поскольку фразы в телефонных диалогах не всегда верно переводятся в текст, сами фразы сравнительно короткие. А в случае людей-операторов ещё и очень вариативные, то кластеризация оказалась очень некачественной.
	\section{Улучение кластеризации}
	В качестве решения проблемы описанной выше было решено использовать данные из фраз человека. До этого для всех фраз человека между двумя фразами оператора, они кластеризировались и никак не использовались. 
	
	Было решено кластеризировать тексты пользователей. Но поскольку как описывалось выше, кластеризация не достаточно хорошая, то необходимо было отсеять плохие кластеры во избежание каскадных ошибок.
	
	Для этого использовалось попарное сравнение фраз внутри каждого кластера. Для этого сравнивались наборы слов внутри фразы с весами. Если точность превышала порог 0.5, то пара считалась хорошей.
	
	Поскольку проверять все пары оказалось очень долго, то для каждого кластера бралась случайная выборка, равная утроенному размеру кластера. Это, в силу достаточно больших размеров кластеров, статистически показывало те же результаты, что и полная выборка.
	
	
	
	
	%%% Так помечается начало обзора. % добавить комментарий Ctrl+T, убрать - Ctrl+U
	%\startrelatedwork
	%Пример ссылок в рамках обзора: \cite{example-english, example-russian, unrestricted-jump-evco, doerr-doerr-lambda-lambda-self-adjustment-arxiv}.
	%%% Так помечается конец обзора.
	%\finishrelatedwork
	%Вне обзора:~\cite{bellman}.
	%
	%\section{Таблицы}\label{sec:tables}
	%
	%В качестве примера таблицы приведена таблица~\ref{tab1}.
	%
	%\begin{table}[!h]
	%\caption{Таблица умножения (фрагмент)}\label{tab1}
	%\centering
	%\begin{tabular}{|*{18}{c|}}\hline
	%-- & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
	%1  & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
	%2  & 2 & 4 & 6 & 8 & 10 & 12 & 14 & 16 & 18 & 20 & 22 & 24 & 26 & 28 & 30 & 32 & 34 \\\hline
	%3  & 3 & 6 & 9 & 12 & 15 & 18 & 21 & 24 & 27 & 30 & 33 & 36 & 39 & 42 & 45 & 48 & 51 \\\hline
	%4  & 4 & 8 & 12 & 16 & 20 & 24 & 28 & 32 & 36 & 40 & 44 & 48 & 52 & 56 & 60 & 64 & 68 \\\hline
	%\end{tabular}
	%\end{table}
	%
	%Есть еще такое окружение \texttt{tabularx}, его можно аккуратно растянуть на всю страницу.
	%Приведем пример (таблица~\ref{tab2}).
	%
	%\begin{table}[!h]
	%\caption{Таблица умножения с помощью \texttt{tabularx} (фрагмент)}\label{tab2}
	%\centering
	%\begin{tabularx}{\textwidth}{|*{18}{>{\centering\arraybackslash}X|}}\hline
	%-- & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
	%1  & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
	%2  & 2 & 4 & 6 & 8 & 10 & 12 & 14 & 16 & 18 & 20 & 22 & 24 & 26 & 28 & 30 & 32 & 34 \\\hline
	%3  & 3 & 6 & 9 & 12 & 15 & 18 & 21 & 24 & 27 & 30 & 33 & 36 & 39 & 42 & 45 & 48 & 51 \\\hline
	%4  & 4 & 8 & 12 & 16 & 20 & 24 & 28 & 32 & 36 & 40 & 44 & 48 & 52 & 56 & 60 & 64 & 68 \\\hline
	%\end{tabularx}
	%\end{table}
	%
	%\section{Рисунки}
	%
	%Пример рисунка (c помощью \texttt{TikZ}) приведен на рисунке~\ref{fig1}. Под \texttt{pdflatex} можно также
	%использовать \texttt{*.jpg}, \texttt{*.png} и даже \texttt{*.pdf}, под \texttt{latex} можно использовать
	%Metapost. Последний можно использовать и под \texttt{pdflatex}, для чего в стилевике продекларированы
	%номера картинок от~1 до~20.
	%
	%\begin{figure}[!h]
	%\caption{Пример рисунка}\label{fig1}
	%\centering
	%\begin{tikzpicture}[scale=0.7]
	%\draw[thick,->] (0,0)--(3.5,0);
	%\draw[thick,->] (0,0)--(0,3.5);
	%\draw[very thick, red] (0,0)--(3,3);
	%\draw[dashed] (3,0)--(3,3);
	%\draw[dashed] (1.5,0)--(1.5,1.5);
	%\end{tikzpicture}
	%\end{figure}
	%
	%\section{Листинги}
	%
	%В работах студентов кафедры <<Компьютерные технологии>> часто встречаются листинги. Листинги бывают
	%двух основных видов~--- исходный код и псевдокод. Первый оформляется с помощью окружения \texttt{lstlisting}
	%из пакета \texttt{listings}, который уже включается в стилевике и немного настроен. Пример Hello World на Java
	%приведен на листинге~\ref{lst1}. Пример большого листинга~--- в приложении (листинг~\ref{lstX}).
	%
	%\begin{lstlisting}[float=!h,caption={Пример исходного кода на Java},label={lst1}]
	%public class HelloWorld {
	%    public static void main(String[] args) {
	%        System.out.println("Hello, world!");
	%    }
	%}
	%\end{lstlisting}
	%
	%Псевдокод можно оформлять с помощью разных пакетов. В данном стилевике включается пакет \texttt{algorithmicx}.
	%Сам по себе он не генерирует флоатов, поэтому для них используется пакет \texttt{algorithm}.
	%Пример их совместного использования приведен на листинге~\ref{lst2}.
	%
	%\begin{algorithm}[!h]
	%\caption{Пример псевдокода}\label{lst2}
	%\begin{algorithmic}
	%	\Function{IsPrime}{$N$}
	%		\For{$t \gets [2; \lfloor\sqrt{N}\rfloor]$}
	%			\If{$N \bmod t = 0$}
	%				\State\Return \textsc{false}
	%			\EndIf
	%		\EndFor
	%		\State\Return \textsc{true}
	%	\EndFunction
	%\end{algorithmic}
	%\end{algorithm}
	%
	%Наконец, листинги из \texttt{listings} тоже можно подвешивать с помощью \texttt{algorithm},
	%пример на листинге~\ref{lst3}.
	%
	%\begin{algorithm}[!h]
	%\caption{Исходный код и флоат \texttt{algorithm}}\label{lst3}
	%\begin{lstlisting}
	%public class HelloWorld {
	%    public static void main(String[] args) {
	%        System.out.println("Hello, world!");
	%    }
	%}
	%\end{lstlisting}
	%\end{algorithm}
	%
	%\chapter{Проверка сквозной нумерации}
	%
	%Листинг~\ref{lst4} должен иметь номер 4.
	%
	%\begin{algorithm}[!h]
	%\caption{Исходный код и флоат \texttt{algorithm}}\label{lst4}
	%\begin{lstlisting}
	%public class HelloWorld {
	%    public static void main(String[] args) {
	%        System.out.println("Hello, world!");
	%    }
	%}
	%\end{lstlisting}
	%\end{algorithm}
	%
	%Рисунок~\ref{fig2} должен иметь номер 2.
	%
	%\begin{figure}[!h]
	%\caption{Пример рисунка}\label{fig2}
	%\centering
	%\begin{tikzpicture}[scale=0.7]
	%\draw[thick,->] (0,0)--(3.5,0);
	%\draw[thick,->] (0,0)--(0,3.5);
	%\draw[very thick, red] (0,0)--(3,3);
	%\draw[dashed] (3,0)--(3,3);
	%\draw[dashed] (1.5,0)--(1.5,1.5);
	%\end{tikzpicture}
	%\end{figure}
	%
	%Таблица~\ref{tab3} должна иметь номер 3.
	%
	%\begin{table}[!h]
	%\caption{Таблица умножения с помощью \texttt{tabularx} (фрагмент)}\label{tab3}
	%\centering
	%\begin{tabularx}{\textwidth}{|*{18}{>{\centering\arraybackslash}X|}}\hline
	%-- & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
	%1  & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
	%2  & 2 & 4 & 6 & 8 & 10 & 12 & 14 & 16 & 18 & 20 & 22 & 24 & 26 & 28 & 30 & 32 & 34 \\\hline
	%3  & 3 & 6 & 9 & 12 & 15 & 18 & 21 & 24 & 27 & 30 & 33 & 36 & 39 & 42 & 45 & 48 & 51 \\\hline
	%4  & 4 & 8 & 12 & 16 & 20 & 24 & 28 & 32 & 36 & 40 & 44 & 48 & 52 & 56 & 60 & 64 & 68 \\\hline
	%\end{tabularx}
	%\end{table}
	%
	%\chapterconclusion
	%
	%В конце каждой главы желательно делать выводы. Вывод по данной главе~--- нумерация работает корректно, ура!
	%
	%%% Макрос для заключения. Совместим со старым стилевиком.
	%\startconclusionpage
	%
	%В данном разделе размещается заключение.
	%
	%\printmainbibliography
	%
	%%% После этой команды chapter будет генерировать приложения, нумерованные русскими буквами.
	%%% \startappendices из старого стилевика будет делать то же самое
	%\appendix
	%
	%\chapter{Пример приложения}\label{sec:app:1}
	%
	%В приложениях рисунки, таблицы и другие подобные элементы нумеруются по приложениям с соответствующим префиксом. Проверим это.
	%
	%Листинг~\ref{lst4:apx} должен иметь номер А.1.
	%
	%\begin{algorithm}[!h]
	%\caption{Исходный код и флоат \texttt{algorithm}}\label{lst4:apx}
	%\begin{lstlisting}
	%public class HelloWorld {
	%    public static void main(String[] args) {
	%        System.out.println("Hello, world!");
	%    }
	%}
	%\end{lstlisting}
	%\end{algorithm}
	%
	%Рисунок~\ref{fig2:apx} должен иметь номер A.1.
	%
	%\begin{figure}[!h]
	%\caption{Пример рисунка}\label{fig2:apx}
	%\centering
	%\begin{tikzpicture}[scale=0.7]
	%\draw[thick,->] (0,0)--(3.5,0);
	%\draw[thick,->] (0,0)--(0,3.5);
	%\draw[very thick, red] (0,0)--(3,3);
	%\draw[dashed] (3,0)--(3,3);
	%\draw[dashed] (1.5,0)--(1.5,1.5);
	%\end{tikzpicture}
	%\end{figure}
	%
	%Таблица~\ref{tab3:apx} должна иметь номер A.1.
	%
	%\begin{table}[!h]
	%\caption{Таблица умножения с помощью \texttt{tabularx} (фрагмент)}\label{tab3:apx}
	%\centering
	%\begin{tabularx}{\textwidth}{|*{18}{>{\centering\arraybackslash}X|}}\hline
	%-- & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
	%1  & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
	%2  & 2 & 4 & 6 & 8 & 10 & 12 & 14 & 16 & 18 & 20 & 22 & 24 & 26 & 28 & 30 & 32 & 34 \\\hline
	%3  & 3 & 6 & 9 & 12 & 15 & 18 & 21 & 24 & 27 & 30 & 33 & 36 & 39 & 42 & 45 & 48 & 51 \\\hline
	%4  & 4 & 8 & 12 & 16 & 20 & 24 & 28 & 32 & 36 & 40 & 44 & 48 & 52 & 56 & 60 & 64 & 68 \\\hline
	%\end{tabularx}
	%\end{table}
	%
	%Заодно проверим нумерованные и ненумерованные перечисления. Ненумерованные:
	%\begin{itemize}
	%    \item пункт А;
	%    \item пункт Б;
	%    \item пункт В.
	%\end{itemize}
	%
	%Нумерованные списки нескольких уровней:
	%\begin{enumerate}
	%    \item первый элемент;
	%    \item второй элемент с подэлементами:
	%    \begin{enumerate}
	%        \item первый подэлемент;
	%        \item второй подэлемент;
	%        \item третий подэлемент.
	%    \end{enumerate}
	%    \item третий элемент;
	%    \item четвертый элемент;
	%    \item пятый элемент;
	%    \item шестой элемент;
	%    \item седьмой элемент;
	%    \item восьмой элемент;
	%    \item девятый элемент;
	%    \item десятый элемент.
	%\end{enumerate}
	%
	%\chapter{Еще один пример приложения с неимоверно длиннющим названием для тестирования переносов}\label{sec:app:2}
	%
	%Проверим на примере таблиц, что нумерация в приложениях~--- по приложениям.
	%Таблица~\ref{tab3:apx2} должна иметь номер Б.1.
	%
	%\begin{table}[!h]
	%\caption{Таблица умножения с помощью \texttt{tabularx} (фрагмент)}\label{tab3:apx2}
	%\centering
	%\begin{tabularx}{\textwidth}{|*{18}{>{\centering\arraybackslash}X|}}\hline
	%-- & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
	%1  & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
	%2  & 2 & 4 & 6 & 8 & 10 & 12 & 14 & 16 & 18 & 20 & 22 & 24 & 26 & 28 & 30 & 32 & 34 \\\hline
	%3  & 3 & 6 & 9 & 12 & 15 & 18 & 21 & 24 & 27 & 30 & 33 & 36 & 39 & 42 & 45 & 48 & 51 \\\hline
	%4  & 4 & 8 & 12 & 16 & 20 & 24 & 28 & 32 & 36 & 40 & 44 & 48 & 52 & 56 & 60 & 64 & 68 \\\hline
	%\end{tabularx}
	%\end{table}
	%
	%\chapter{Пример огромного листинга}
	%
	%\begin{lstlisting}[caption={Пример большого листинга},label={lstX}]
	%import java.util.*;
	%
	%public class Example {
	%    static int[] restoreOutgoing(int[] g, int[] outgoing,
	%                                 int vertex, int mask) {
	%        int[] rv = new int[1 + Integer.bitCount(mask)];
	%        int n = g.length;
	%        int current = rv.length - 1;
	%        while (true) {
	%            rv[current] = vertex;
	%            if (current == 0) {
	%                if (vertex != 0) {
	%                    throw new AssertionError();
	%                }
	%                return rv;
	%            }
	%            mask ^= 1 << (vertex - 1);
	%            int prevMask = outgoing[mask] & g[vertex];
	%            if (prevMask == 0) {
	%                throw new AssertionError();
	%            }
	%            vertex = Integer.numberOfTrailingZeros(prevMask);
	%            --current;
	%        }
	%    }
	%
	%    static int[] restoreIncoming(int[] g, int[] incoming,
	%                                 int vertex, int mask) {
	%        int[] rv = new int[1 + Integer.bitCount(mask)];
	%        int n = g.length;
	%        int current = 0;
	%        while (true) {
	%            rv[current] = vertex;
	%            if (current == rv.length - 1) {
	%                if (vertex != 0) {
	%                    throw new AssertionError();
	%                }
	%                return rv;
	%            }
	%            mask ^= 1 << (vertex - 1);
	%            int nextMask = incoming[mask] & g[vertex];
	%            if (nextMask == 0) {
	%                throw new AssertionError();
	%            }
	%            vertex = Integer.numberOfTrailingZeros(nextMask);
	%            ++current;
	%        }
	%    }
	%}
	%\end{lstlisting}
	
\end{document}
