\documentclass[specification,annotation]{itmo-student-thesis}

\usepackage{fontspec}
\setmainfont[Mapping=tex-text]{CMU Serif}
\setsansfont{CMU Sans Serif}                %% задаёт шрифт без засечек
\setmonofont{CMU Typewriter Text}  

%% Опции пакета:
%% - specification - если есть, генерируется задание, иначе не генерируется
%% - annotation - если есть, генерируется аннотация, иначе не генерируется
%% - times - делает все шрифтом Times New Roman, собирается с помощью xelatex
%% - languages={...} - устанавливает перечень используемых языков. По умолчанию это {english,russian}.
%%                     Последний из языков определяет текст основного документа.

%% Делает запятую в формулах более интеллектуальной, например:
%% $1,5x$ будет читаться как полтора икса, а не один запятая пять иксов.
%% Однако если написать $1, 5x$, то все будет как прежде.
\usepackage{icomma}

%% Один из пакетов, позволяющий делать таблицы на всю ширину текста.
\usepackage{tabularx}

%% Данные пакеты необязательны к использованию в бакалаврских/магистерских
%% Они нужны для иллюстративных целей
%% Начало
\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage{filecontents}
\begin{filecontents}{bachelor-thesis.bib}
	@online{ doerr-doerr-lambda-lambda-self-adjustment-arxiv,
		year        = {2015},
		title       = {Optimal Parameter Choices Through Self-Adjustment: Applying the 1/5-th Rule in
			Discrete Settings},
		author      = {Benjamin Doerr and Carola Doerr},
		url         = {http://arxiv.org/abs/1504.03212},
		year        = {2015},
		langid      = {english}
	}
	
	@inproceedings{ example-english,
		year        = {2015},
		booktitle   = {Proceedings of IEEE Congress on Evolutionary Computation},
		author      = {Maxim Buzdalov and Anatoly Shalyto},
		title       = {Hard Test Generation for Augmenting Path Maximum Flow 
			Algorithms using Genetic Algorithms: Revisited},
		pages       = {2121-2128},
		langid      = {english}
	}
	
	@article{ example-russian,
		author      = {Максим Викторович Буздалов},
		title       = {Генерация тестов для олимпиадных задач по программированию 
			с использованием генетических алгоритмов},
		journal     = {Научно-технический вестник {СПбГУ} {ИТМО}},
		number      = {2(72)},
		year        = {2011},
		pages       = {72-77},
		langid      = {russian}
	}
	
	@article{ unrestricted-jump-evco,
		author      = {Maxim Buzdalov and Benjamin Doerr and Mikhail Kever},
		title       = {The Unrestricted Black-Box Complexity of Jump Functions},
		journal     = {Evolutionary Computation},
		year        = {2016},
		note        = {Accepted for publication},
		langid      = {english}
	}
	
	@book{ bellman,
		author      = {R. E. Bellman},
		title       = {Dynamic Programming},
		address     = {Princeton, NJ},
		publisher   = {Princeton University Press},
		numpages    = {342},
		pagetotal   = {342},
		year        = {1957},
		langid      = {english}
	}
\end{filecontents}
%% Конец

%% Указываем файл с библиографией.
\addbibresource{bachelor-thesis.bib}

\begin{document}
	
	\studygroup{M3437}
	\title{Разработка алгоритмов работы с формальной моделью диалогов, представленных в виде графов}
	\author{Савон Юлия Константиновна}{Савон Ю.К.}
	\supervisor{Ульянцев Владимир Игоревич}{Ульянцев В.И.}{доцент, к.т.н.}{доцент факультета информационных технологий и программирования Университета ИТМО}
	\publishyear{2020}
	%% Дата выдачи задания. Можно не указывать, тогда надо будет заполнить от руки.
	\startdate{01}{сентября}{2019}
	%% Срок сдачи студентом работы. Можно не указывать, тогда надо будет заполнить от руки.
	\finishdate{10}{июня}{2020}
	%% Дата защиты. Можно не указывать, тогда надо будет заполнить от руки.
	\defencedate{25}{июня}{2020}
	
	\addconsultant{Ступаков И.М.}{канд. тех. наук, доцент}
	
	\secretary{Павлова О.Н.}
	
	%% Задание
	%%% Техническое задание и исходные данные к работе
	\technicalspec{Требуется провести исследование и разработать набор алгоритмов для выявления отвлечений в графовой модели для телефонной диалоговой системы.
		Алгоритм принимает набор диалогов, в размере нескольких тысяч. Предварительно выстроенный граф и кластеризацию для фраз оператора. 
		
		На выходе ожидается получить набор отвлечений и перестроенный граф. В качестве метрики качества будет использоваться сравнение с уже существующими графами, которые создавались вручную.}
	
	%%% Содержание выпускной квалификационной работы (перечень подлежащих разработке вопросов)
	\plannedcontents{Пояснительная записка должна описывать предметную область диалогов представленных в виде графов. Так же формулировать цель и задачу выделения отвлечений, содержать описание алгоритмов их поиска. Должны быть описаны сложности и методы их разрешения, если они возникали. Кроме того должны быть приведены примеры работы алгоритмов и сравнение с существующими решениями. Кроме того пояснительная записка должна содержать описания задач из смежных областей и их то, как эти задачи связны с задачей решаемой в работе.}%TODO добавить какие конкретно смежные области
	
	%%% Исходные материалы и пособия 
	\plannedsources{\begin{enumerate}
			\item Среда разработки Visial Studio Code;
			\item ГОСТ 7.32--2001 <<Система стандартов по информации, библиотечному и издательскому делу. Отчет о научно-исследовательской работе. Структура и правила оформления>>.
	\end{enumerate}}
	
	%%% Цель исследования
	\researchaim{Разработа алгоритма выделяющего отвлечения в диалоге, представленном в виде графа.}
	
	%%% Задачи, решаемые в ВКР
	\researchtargets{\begin{enumerate}
			\item Разработать алгоритмы выделения отвлечий;
			\item Реализовать описанные алгоритмы;
			\item Перестроить граф в соответствии с используемой моделью в компании;
			\item Проанализировать результаты работы алгоритмов;
			\item Интегрировать разработки в инфраструктуру компании.
	\end{enumerate}}
	
	%%% Использование современных пакетов компьютерных программ и технологий
	\addadvancedsoftware{Пакет \texttt{tabularx} для чуть более продвинутых таблиц}{\ref{sec:tables}, Приложения~\ref{sec:app:1}, \ref{sec:app:2}}
	\addadvancedsoftware{Пакет \texttt{biblatex} и программное средство \texttt{biber}}{Список использованных источников}
	
	%%% Краткая характеристика полученных результатов 
	\researchsummary{}
	
	%%% Гранты, полученные при выполнении работы 
	\researchfunding{}%TODO вписать стипендию
	
	%%% Наличие публикаций и выступлений на конференциях по теме выпускной работы
	\researchpublications{По теме этой работы был сделан доклад на Конгрессе Молодых Ученых.
		%\begin{refsection}
		%%Однако покажу, как можно ссылаться на свои публикации из списка литературы:
		%%\nocite{example-english, example-russian}
		%%\printannobibliography
		%\end{refsection}
	}
	
	%% Эта команда генерирует титульный лист и аннотацию.
	\maketitle{Бакалавр}
	
	%% Оглавление
	\tableofcontents
	
	%% Макрос для введения. Совместим со старым стилевиком.
	\startprefacepage
	
	Эта работа посвящена исследованию в области диалоговых систем.
	
	Диалоговая система -- алгоритм, который умеет принимать участие в диалоге на естественном языке и использует правила общения между людьми.
	
	В качестве примера диалоговых систем можно привести: 
	\begin{itemize}
		\item чат-боты
		\item голосовые помощники
		\item автоответчики в колл-центрах
	\end{itemize}

	Такие диалоговые системы могут быть как довольно простыми (например чат-бот отвечающий на заранее известный набор команд), так и сложными (например бот, отвечающий на вопрос на естественном языке и в качестве ответа возвращающий некоторую информацию из базы знаний).
	
	В последнее время набрали популярность технологии распознования и генерации речи, которые позволили создавать диалоговые системы, ведущие телефонный разговор. Данная работа заточена под алгоритмы для телефонных звонков.
	
	Такие звонки с одной стороны должны быть не отличимы от звонков человека, с другой они должны придерживаться некоторого сценария.
	
	\textbf{Сценарий диалога с оператором} — некоторый алгоритм, предоставленный человеку, который звонит по заданному набору телефонных номеров. Целью сценария обычно является получить или донести до клиента информацию. 
	
	Несмотря на то, что под сценарием диалога мы понимаем некоторый алгоритм, необходимо понимать что для человека и диалоговой системы это принципиально разные сущности. Между скриптом\footnote{Здесь и далее в тексте \textbf{скрипт} и \textbf{сценарий} будут использоваться как синонимы} и алгоритмом, с точки зрения набора действий для машины есть большая разница. 
	
	Для человека это скорее список вопросов которые он должен задать и информация о возможных продуктах и услугах. Кроме того человек может помнить некоторые факты и выдавать их дополнительно зависимости от контекста. он сам умеет обрабатывать ситуации такие как отвлечение от основных вопросов или переспрашивание.
	
	Для графа же, любую реакцию надо прописывать, все возможные данные хранить и обновлять. Кроме того есть требование поддерживать этот скрипт доступным для восприятия человеком (например лингвистом), поскольку возникает необходимость в ручном анализе и редактировании.
	
	\textbf{Телефонная диалоговая система} — программа, которая используя сценарий умеет проводить диалог с клиентом, интерпретировать и записывать  информацию полученную от клиента, а так же состояния завершенного разговора. Кроме того робот умеет отвечать на заранее прописанный в скрипте набор вопросов и возвращаться обратно к диалогу.
	
	На данный момент существуют графы для диалогов, которые создаются вручную. Но писать их долго, а продумывать все важные случаи реакций сложно и трудоёмко. 
	
	Кроме того хочется иметь возможность усложнять вариативность диалогов. В связи с этим, ставится глобальная задача по представлению набора диалогов в виде графа. 
	
	Поскольку некоторые из вопросы или дискуссии могут возникнуть в любом месте диалога. И количество таких случаев достаточно велико. То было решено отделить их в отдельные подграфы и сделать возможность переходить в них при некоторых условиях из каждой вершины. Вдальнейшем мы будем называть такие случаи \textbf{отвлечениями}.
	
	В работе будут рассмотрены различные алгоритмы поиска таких отвлечений. А так же рассмотренны варианты улучшения для кластеризации, использующие данные о контексте.
	
	%% Начало содержательной части.
	\chapter{Обзор}
	\section{Описание предметной области}
	Изначальная общая задача стоит следующая: есть диалоги, необходимо восстановить граф и найти отвлечения.
	
	На данный момент кроме восстанавливаемой нами модели есть граф который составляется вручную. В этом графе вершинами являются кластеры фраз диалоговой системы, а рёбрами фразы человека. То есть при ответах человека происходит переход в разные новые вершины.
	
	Особенностями данной структуры, которые важно отметить, является то, что помимо обычных переходов существуют так же скрытые переходы, которые по умолчанию могут встретиться в любом месте. В качестве примера можно привести вопрос: "А какую компанию вы представляете?". При звонке люди могут задать этот вопрос не сразу.
	
	Для того, чтобы не рассматривать каждый такой случай при переходе из каждой вершины, выделяются $\textbf{отвлечения}$. 
	
	$\textbf{Отвлечение}$ - вопрос, который может быть задан в любом месте диалога. 
	
	В задаче восстанавления будет использоваться несколько другой граф. В нём вершинами будут являться кластеры и фраз оператора, и фраз человека. А ребрами последовательные пары фраз из кластеров в диалоге.
	
	\section{Анализ}
	На вход подаётся набор диалогов по которым нужно получить граф для диалоговой системы, который бы мог проводить аналогичные диалоги.
	
	Граф, если получать его путём обычной кластеризации операторских фраз, получается очень громоздким. В нём плохо видно структуру, его сложно анализировать.
	
	Поскольку конечной целью является построить автомат аналогичный тому, что работает в продуктовой части команды, то появляется требование привести его в состояние, когда его можно изучать вручную. 
	
	То есть так же как и в графе создаваемом вручную, появляется необходимость выделить отвлечения. В этом случае его структура становится более удобной для изучения. Его можно использовать как вспомогательный инструмент. 
	
	Такие выделения отвлечений позволяют грамотно обрабатывать сценарии, которых не было в изначальном наборе диалогов. Если такие отвлечения не выделить, то в случае вопроса, не предусмотренного в этом месте диалоговая система либо ответит невпопад, либо зависнет.
	
	Необходима хорошая кластеризация текстов, поскольку любой алгоритм выделения отвлечений так или иначе будет опираться на эту кластеризацию. При таких кластеризациях полезно учитывать имеющуюся информацию, то есть фразы до текущей и после.
	
	
	\section{Постановка задачи}
	В связи с описаной выше проблемой громоздкости графа, появляется задача выделить отвлечения, которые могли бы встретиться в любом месте.
	
	В случае, когда диалог проводит оператор такие вопросы нет необходимости расписывать, но диалоговой системе нужен чёткий скрипт.
	
	Необходимо выделить отвлечения и перестроить граф таким образом, чтобы он покрывал большее количество диалогов и его было проще анализировать.
	
	\section{Выводы по первой главе}
	Рассмотрена предметная область графовой структуры диалогов. Разобрана структура продуктового графа и структура графа для восстанавливаемой модели. Проведён анализ задачи восстановления графа. Поставлена задача выделения отвлечений. 
	
	\chapter{Теоретическая часть}
	\section{Модель предлагаемого решения}
	Поскольку граф на данном этапе всё ещё перестраивается, то информация о произнесенных человеком фразах является полезной, так как содержит в себе контекст. Поэтому мы оставляем фразы человека в качестве вершин.
	
	Нужно понимать, что изначально кластеризация проводилась только по фразам оператора. Фразы вершин же были разделены на группы, где для каждой группы совпадала предыдущая и последующая вершины оператора. И уже внутри этих групп бились на некоторые подгруппы.
	
	Рассмотрим два подхода в решении задачи выделения отвлечений:
	
	\begin{itemize}
		\item Первый подход заключается в том, чтобы выделить вершины, в которые идёт много рёбер. Порог считается функцией от количества кластеров на которые бъются фразы оператора.
		
		Мы предполагаем, что поскольку отвлечение встречается в разных местах, то и рёбра будут идти в него из множества различных вершин. Такая гипотеза является хорошей, поскольку в обычном графе в вершину обычно приходит одна или две ветки, в случае же отвлечения их должно быть много, или же оно встречается крайне редко.
		
		\item В качестве другого подхода можно выделить циклы и сказать, что вершина следующая в диалоге за вершиной повторения с некоторой вероятностью будет являться началом отвечения.
		
		Здесь мы пользуемся наблюдением, что после отвлечения на стронний вопрос, оператор зачастую повторяет ту же или схожую фразу для возвращения в сценарий. Более того, эта идея используется в графе, который реализован для реального окружения. Там диалоговая система так же повторяет фразу, её сокращенную версию или её иную формулировку, которую произносил, перед тем, как перейти в отвлечение.
	\end{itemize}\hskip
	
	Поскольку подходы используют разные идеи их так же имеет смысл комбинировать и использовать данные полученные в обоих подходах.
	
	\section{Соответствие поставленным требованиям}
	Такие алгоритмы позволят найти для диалогов которые были проведены с системой, отвлечения, и сопоставить их с выделенными лингвистами вручную для графа.
	
	\chapter{Реализация}
	\section{Подход с большим количеством рёбер входящих в вершину}\\
	Выбираются вершины, в которые входит много ребер. Для значений размеров кластеров в интервале от двенадцати до пятнадцати был выбран параметр три. При увеличении количества кластеров соответственно должен увеличиваться и порог.
	
	Во время тестирования на реальных диалогов человека с человеком была выявлена важная особенность. На работу алгоритма очень сильно влияет качество кластеризации. Поскольку фразы в телефонных диалогах не всегда верно переводятся в текст, сами фразы сравнительно короткие. А в случае людей-операторов ещё и очень вариативные, то кластеризация оказалась очень некачественной.
	
	\section{Подход с поиском циклов}\\
	После кластеризации ищутся пары вершин для которых кластеры совпадают. Так же было добавлено ограничение на расстояние между ними в диалоге. Оно должно быть не слишком велико, поскольку ясно что отвлечение бывает длинным очень редко, а иначе можно случайно выкинуть почти весь диалог.
	
	В этом случае в качестве потенциальных отвлечений мы выбираем вершины человеческих фраз которые первые следуют после начала цикла. После перевода графа в продуктовый режим у нас эти вершины станут рёбрами и таким образом это будут триггеры, которые будут перенаправлять русло диалога в отвлечение.
	\section{Улучение кластеризации}
	В качестве решения проблемы некачественной кластеризации было предложено использовать данные из фраз человека. До этого для всех фраз человека между двумя фразами оператора, они кластеризировались и никак не использовались. 
	
	Было решено кластеризировать тексты пользователей. Но поскольку как описывалось выше, кластеризация не достаточно хорошая, то необходимо было отсеять плохие кластеры во избежание каскадных ошибок.
	
	%Нужно понимать, что если отсеять всё кроме одинаковых фраз, то их останется очень мало и ценной информации они нести не будут.
	
	Для этого использовалось попарное сравнение фраз внутри каждого кластера. Для этого сравнивались наборы слов внутри фразы с весами. Если точность превышала порог 0.5, то пара считалась хорошей.
	
	Константа 0.5 была выведена эмперически. Для большего значения в кластре начинало содержаться большое количество фраз разных по смыслу. 
	
	Проверять все пары оказалось очень долго $O(n^2)$, а в предыдущей части восставновления все операции имели ассимтотику не более чем $O(n \log n)$, то получилось так, что эта часть занимала значительно больше половины времени от всего восстановления графа. 
	
	Тогда было решено для каждого кластера брать случайную выборку, равная утроенному размеру кластера, ассимптотически это занимало уже $O(n)$. В силу достаточно больших размеров кластеров (размер их для основной массы данных состовляет несколько сотен фраз нескольких сотен фраз), статистически показывало те же результаты, что и полная выборка.
	
	Ниже приведён псевдокод для данной функции:
	
	
	\chapter{Полученные результаты}
	\section{Используемые данные}
	В качестве данных использовалось два принципиально разных типа наборов диалогов. Первые проводились уже с существующим роботом скриптом. Второй тип, это данные диалогов человека с человеком.
	
	Особенность первого заключается в том, что там легко кластеризовать фразы оператора, так как они произносятся всегда одинаково. Так же для этого случая есть возможность перевести полученный граф в тот же формат и сравнить полученный результат с оригиналом.
	
	Особенности второго соответсвенно следующие: во первых там говорят разные операторы и у них разный стиль подачи одних и тех же данных. Во вторых диалоги более сложные и зачастую отходят от скрипта. В третьих люди решают более сложные вопросы и умеют давать ответы на не предусмотренные скриптом вопросы. На этот вариант данных стоит ориентироваться, но в связи с отсутствием оригинального скрипта в удобном формате напрямую сравнить полученный результат представляется возможным только вручную.
	
	В обоих случаях есть сложности с переводом речи людей в текст, поэтому иногда даже рассматривая текст диалога вручную нельзя понять что человек имел ввиду.
	
	\chapter{Заключение}
	\section{Улучение кластеризации}
	Алгоритм вносит небольшие изменения и способен объединять некоторые одинаковые кластеры.
	
	\section{Алгоритм поиска отвлечений по рёбрам}
	Для данного алгоритма критично качество кластеризации и наличие небольшого количества выбросов. 
	
	В случае с данными из реальных диалогов зачастую не было видно правильно выделеных отвлечений из-за смешения кластеров и операторских и человеческих вершин.
	
	Для данных из диалогов с существующей диалоговой системой алгоритм находил практически все отвлечения. Основная причина столь большого различия в том, что операторские фразы во втором случае кластеризуются практически идеально.
	
%	\begin{algorithmic}
%		\def{IsPrime}{$N$}
%		\For{$t \gets [2; \lfloor\sqrt{N}\rfloor]$}
%		\If{$N \bmod t = 0$}
%		\State\Return \textsc{false}
%		\EndIf
%		\EndFor
%		\State\Return \textsc{true}
%		\EndFunction
%	\end{algorithmic}
	
	
	
	%%% Так помечается начало обзора. % добавить комментарий Ctrl+T, убрать - Ctrl+U
	%\startrelatedwork
	%Пример ссылок в рамках обзора: \cite{example-english, example-russian, unrestricted-jump-evco, doerr-doerr-lambda-lambda-self-adjustment-arxiv}.
	%%% Так помечается конец обзора.
	%\finishrelatedwork
	%Вне обзора:~\cite{bellman}.
	%
	%\section{Таблицы}\label{sec:tables}
	%
	%В качестве примера таблицы приведена таблица~\ref{tab1}.
	%
	%\begin{table}[!h]
	%\caption{Таблица умножения (фрагмент)}\label{tab1}
	%\centering
	%\begin{tabular}{|*{18}{c|}}\hline
	%-- & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
	%1  & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
	%2  & 2 & 4 & 6 & 8 & 10 & 12 & 14 & 16 & 18 & 20 & 22 & 24 & 26 & 28 & 30 & 32 & 34 \\\hline
	%3  & 3 & 6 & 9 & 12 & 15 & 18 & 21 & 24 & 27 & 30 & 33 & 36 & 39 & 42 & 45 & 48 & 51 \\\hline
	%4  & 4 & 8 & 12 & 16 & 20 & 24 & 28 & 32 & 36 & 40 & 44 & 48 & 52 & 56 & 60 & 64 & 68 \\\hline
	%\end{tabular}
	%\end{table}
	%
	%Есть еще такое окружение \texttt{tabularx}, его можно аккуратно растянуть на всю страницу.
	%Приведем пример (таблица~\ref{tab2}).
	%
	%\begin{table}[!h]
	%\caption{Таблица умножения с помощью \texttt{tabularx} (фрагмент)}\label{tab2}
	%\centering
	%\begin{tabularx}{\textwidth}{|*{18}{>{\centering\arraybackslash}X|}}\hline
	%-- & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
	%1  & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
	%2  & 2 & 4 & 6 & 8 & 10 & 12 & 14 & 16 & 18 & 20 & 22 & 24 & 26 & 28 & 30 & 32 & 34 \\\hline
	%3  & 3 & 6 & 9 & 12 & 15 & 18 & 21 & 24 & 27 & 30 & 33 & 36 & 39 & 42 & 45 & 48 & 51 \\\hline
	%4  & 4 & 8 & 12 & 16 & 20 & 24 & 28 & 32 & 36 & 40 & 44 & 48 & 52 & 56 & 60 & 64 & 68 \\\hline
	%\end{tabularx}
	%\end{table}
	%
	%\section{Рисунки}
	%
	%Пример рисунка (c помощью \texttt{TikZ}) приведен на рисунке~\ref{fig1}. Под \texttt{pdflatex} можно также
	%использовать \texttt{*.jpg}, \texttt{*.png} и даже \texttt{*.pdf}, под \texttt{latex} можно использовать
	%Metapost. Последний можно использовать и под \texttt{pdflatex}, для чего в стилевике продекларированы
	%номера картинок от~1 до~20.
	%
	%\begin{figure}[!h]
	%\caption{Пример рисунка}\label{fig1}
	%\centering
	%\begin{tikzpicture}[scale=0.7]
	%\draw[thick,->] (0,0)--(3.5,0);
	%\draw[thick,->] (0,0)--(0,3.5);
	%\draw[very thick, red] (0,0)--(3,3);
	%\draw[dashed] (3,0)--(3,3);
	%\draw[dashed] (1.5,0)--(1.5,1.5);
	%\end{tikzpicture}
	%\end{figure}
	%
	%\section{Листинги}
	%
	%В работах студентов кафедры <<Компьютерные технологии>> часто встречаются листинги. Листинги бывают
	%двух основных видов~--- исходный код и псевдокод. Первый оформляется с помощью окружения \texttt{lstlisting}
	%из пакета \texttt{listings}, который уже включается в стилевике и немного настроен. Пример Hello World на Java
	%приведен на листинге~\ref{lst1}. Пример большого листинга~--- в приложении (листинг~\ref{lstX}).
	%
	%\begin{lstlisting}[float=!h,caption={Пример исходного кода на Java},label={lst1}]
	%public class HelloWorld {
	%    public static void main(String[] args) {
	%        System.out.println("Hello, world!");
	%    }
	%}
	%\end{lstlisting}
	%
	%Псевдокод можно оформлять с помощью разных пакетов. В данном стилевике включается пакет \texttt{algorithmicx}.
	%Сам по себе он не генерирует флоатов, поэтому для них используется пакет \texttt{algorithm}.
	%Пример их совместного использования приведен на листинге~\ref{lst2}.
	%
%	\begin{algorithm}[!h]
%	\caption{Пример псевдокода}\label{lst2}
%	\begin{algorithmic}
%		\Function{IsPrime}{$N$}
%			\For{$t \gets [2; \lfloor\sqrt{N}\rfloor]$}
%				\If{$N \bmod t = 0$}
%					\State\Return \textsc{false}
%				\EndIf
%			\EndFor
%			\State\Return \textsc{true}
%		\EndFunction
%	\end{algorithmic}
%	\end{algorithm}
	%
	%Наконец, листинги из \texttt{listings} тоже можно подвешивать с помощью \texttt{algorithm},
	%пример на листинге~\ref{lst3}.
	%
	%\begin{algorithm}[!h]
	%\caption{Исходный код и флоат \texttt{algorithm}}\label{lst3}
	%\begin{lstlisting}
	%public class HelloWorld {
	%    public static void main(String[] args) {
	%        System.out.println("Hello, world!");
	%    }
	%}
	%\end{lstlisting}
	%\end{algorithm}
	%
	%\chapter{Проверка сквозной нумерации}
	%
	%Листинг~\ref{lst4} должен иметь номер 4.
	%
	%\begin{algorithm}[!h]
	%\caption{Исходный код и флоат \texttt{algorithm}}\label{lst4}
	%\begin{lstlisting}
	%public class HelloWorld {
	%    public static void main(String[] args) {
	%        System.out.println("Hello, world!");
	%    }
	%}
	%\end{lstlisting}
	%\end{algorithm}
	%
	%Рисунок~\ref{fig2} должен иметь номер 2.
	%
	%\begin{figure}[!h]
	%\caption{Пример рисунка}\label{fig2}
	%\centering
	%\begin{tikzpicture}[scale=0.7]
	%\draw[thick,->] (0,0)--(3.5,0);
	%\draw[thick,->] (0,0)--(0,3.5);
	%\draw[very thick, red] (0,0)--(3,3);
	%\draw[dashed] (3,0)--(3,3);
	%\draw[dashed] (1.5,0)--(1.5,1.5);
	%\end{tikzpicture}
	%\end{figure}
	%
	%Таблица~\ref{tab3} должна иметь номер 3.
	%
	%\begin{table}[!h]
	%\caption{Таблица умножения с помощью \texttt{tabularx} (фрагмент)}\label{tab3}
	%\centering
	%\begin{tabularx}{\textwidth}{|*{18}{>{\centering\arraybackslash}X|}}\hline
	%-- & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
	%1  & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
	%2  & 2 & 4 & 6 & 8 & 10 & 12 & 14 & 16 & 18 & 20 & 22 & 24 & 26 & 28 & 30 & 32 & 34 \\\hline
	%3  & 3 & 6 & 9 & 12 & 15 & 18 & 21 & 24 & 27 & 30 & 33 & 36 & 39 & 42 & 45 & 48 & 51 \\\hline
	%4  & 4 & 8 & 12 & 16 & 20 & 24 & 28 & 32 & 36 & 40 & 44 & 48 & 52 & 56 & 60 & 64 & 68 \\\hline
	%\end{tabularx}
	%\end{table}
	%
	%\chapterconclusion
	%
	%В конце каждой главы желательно делать выводы. Вывод по данной главе~--- нумерация работает корректно, ура!
	%
	%%% Макрос для заключения. Совместим со старым стилевиком.
	%\startconclusionpage
	%
	%В данном разделе размещается заключение.
	%
	%\printmainbibliography
	%
	%%% После этой команды chapter будет генерировать приложения, нумерованные русскими буквами.
	%%% \startappendices из старого стилевика будет делать то же самое
	%\appendix
	%
	%\chapter{Пример приложения}\label{sec:app:1}
	%
	%В приложениях рисунки, таблицы и другие подобные элементы нумеруются по приложениям с соответствующим префиксом. Проверим это.
	%
	%Листинг~\ref{lst4:apx} должен иметь номер А.1.
	%
	%\begin{algorithm}[!h]
	%\caption{Исходный код и флоат \texttt{algorithm}}\label{lst4:apx}
	%\begin{lstlisting}
	%public class HelloWorld {
	%    public static void main(String[] args) {
	%        System.out.println("Hello, world!");
	%    }
	%}
	%\end{lstlisting}
	%\end{algorithm}
	%
	%Рисунок~\ref{fig2:apx} должен иметь номер A.1.
	%
	%\begin{figure}[!h]
	%\caption{Пример рисунка}\label{fig2:apx}
	%\centering
	%\begin{tikzpicture}[scale=0.7]
	%\draw[thick,->] (0,0)--(3.5,0);
	%\draw[thick,->] (0,0)--(0,3.5);
	%\draw[very thick, red] (0,0)--(3,3);
	%\draw[dashed] (3,0)--(3,3);
	%\draw[dashed] (1.5,0)--(1.5,1.5);
	%\end{tikzpicture}
	%\end{figure}
	%
	%Таблица~\ref{tab3:apx} должна иметь номер A.1.
	%
	%\begin{table}[!h]
	%\caption{Таблица умножения с помощью \texttt{tabularx} (фрагмент)}\label{tab3:apx}
	%\centering
	%\begin{tabularx}{\textwidth}{|*{18}{>{\centering\arraybackslash}X|}}\hline
	%-- & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
	%1  & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
	%2  & 2 & 4 & 6 & 8 & 10 & 12 & 14 & 16 & 18 & 20 & 22 & 24 & 26 & 28 & 30 & 32 & 34 \\\hline
	%3  & 3 & 6 & 9 & 12 & 15 & 18 & 21 & 24 & 27 & 30 & 33 & 36 & 39 & 42 & 45 & 48 & 51 \\\hline
	%4  & 4 & 8 & 12 & 16 & 20 & 24 & 28 & 32 & 36 & 40 & 44 & 48 & 52 & 56 & 60 & 64 & 68 \\\hline
	%\end{tabularx}
	%\end{table}
	%
	%Заодно проверим нумерованные и ненумерованные перечисления. Ненумерованные:
	%\begin{itemize}
	%    \item пункт А;
	%    \item пункт Б;
	%    \item пункт В.
	%\end{itemize}
	%
	%Нумерованные списки нескольких уровней:
	%\begin{enumerate}
	%    \item первый элемент;
	%    \item второй элемент с подэлементами:
	%    \begin{enumerate}
	%        \item первый подэлемент;
	%        \item второй подэлемент;
	%        \item третий подэлемент.
	%    \end{enumerate}
	%    \item третий элемент;
	%    \item четвертый элемент;
	%    \item пятый элемент;
	%    \item шестой элемент;
	%    \item седьмой элемент;
	%    \item восьмой элемент;
	%    \item девятый элемент;
	%    \item десятый элемент.
	%\end{enumerate}
	%
	%\chapter{Еще один пример приложения с неимоверно длиннющим названием для тестирования переносов}\label{sec:app:2}
	%
	%Проверим на примере таблиц, что нумерация в приложениях~--- по приложениям.
	%Таблица~\ref{tab3:apx2} должна иметь номер Б.1.
	%
	%\begin{table}[!h]
	%\caption{Таблица умножения с помощью \texttt{tabularx} (фрагмент)}\label{tab3:apx2}
	%\centering
	%\begin{tabularx}{\textwidth}{|*{18}{>{\centering\arraybackslash}X|}}\hline
	%-- & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
	%1  & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 \\\hline
	%2  & 2 & 4 & 6 & 8 & 10 & 12 & 14 & 16 & 18 & 20 & 22 & 24 & 26 & 28 & 30 & 32 & 34 \\\hline
	%3  & 3 & 6 & 9 & 12 & 15 & 18 & 21 & 24 & 27 & 30 & 33 & 36 & 39 & 42 & 45 & 48 & 51 \\\hline
	%4  & 4 & 8 & 12 & 16 & 20 & 24 & 28 & 32 & 36 & 40 & 44 & 48 & 52 & 56 & 60 & 64 & 68 \\\hline
	%\end{tabularx}
	%\end{table}
	%
	%\chapter{Пример огромного листинга}
	%
	%\begin{lstlisting}[caption={Пример большого листинга},label={lstX}]
	%import java.util.*;
	%
	%public class Example {
	%    static int[] restoreOutgoing(int[] g, int[] outgoing,
	%                                 int vertex, int mask) {
	%        int[] rv = new int[1 + Integer.bitCount(mask)];
	%        int n = g.length;
	%        int current = rv.length - 1;
	%        while (true) {
	%            rv[current] = vertex;
	%            if (current == 0) {
	%                if (vertex != 0) {
	%                    throw new AssertionError();
	%                }
	%                return rv;
	%            }
	%            mask ^= 1 << (vertex - 1);
	%            int prevMask = outgoing[mask] & g[vertex];
	%            if (prevMask == 0) {
	%                throw new AssertionError();
	%            }
	%            vertex = Integer.numberOfTrailingZeros(prevMask);
	%            --current;
	%        }
	%    }
	%
	%    static int[] restoreIncoming(int[] g, int[] incoming,
	%                                 int vertex, int mask) {
	%        int[] rv = new int[1 + Integer.bitCount(mask)];
	%        int n = g.length;
	%        int current = 0;
	%        while (true) {
	%            rv[current] = vertex;
	%            if (current == rv.length - 1) {
	%                if (vertex != 0) {
	%                    throw new AssertionError();
	%                }
	%                return rv;
	%            }
	%            mask ^= 1 << (vertex - 1);
	%            int nextMask = incoming[mask] & g[vertex];
	%            if (nextMask == 0) {
	%                throw new AssertionError();
	%            }
	%            vertex = Integer.numberOfTrailingZeros(nextMask);
	%            ++current;
	%        }
	%    }
	%}
	%\end{lstlisting}
	
\end{document}
