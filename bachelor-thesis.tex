\documentclass[specification,annotation]{itmo-student-thesis}

\usepackage{fontspec}
\usepackage{amsthm}
\usepackage{float}
\usepackage{subcaption}
\setmainfont[Mapping=tex-text]{CMU Serif}
\setsansfont{CMU Sans Serif}                %% задаёт шрифт без засечек
\setmonofont{CMU Typewriter Text}  

%% Опции пакета:
%% - specification - если есть, генерируется задание, иначе не генерируется
%% - annotation - если есть, генерируется аннотация, иначе не генерируется
%% - times - делает все шрифтом Times New Roman, собирается с помощью xelatex
%% - languages={...} - устанавливает перечень используемых языков. По умолчанию это {english,russian}.
%%                     Последний из языков определяет текст основного документа.

%% Делает запятую в формулах более интеллектуальной, например:
%% $1,5x$ будет читаться как полтора икса, а не один запятая пять иксов.
%% Однако если написать $1, 5x$, то все будет как прежде.
\usepackage{icomma}

%% Один из пакетов, позволяющий делать таблицы на всю ширину текста.
\usepackage{tabularx}
\usepackage{pdfpages}

%% Данные пакеты необязательны к использованию в бакалаврских/магистерских
%% Они нужны для иллюстративных целей
%% Начало
\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage{filecontents}
\begin{filecontents}{bachelor-thesis.bib}
	@article{чернова2007теория,
		title={Теория вероятностей: Учеб. пособие/Новосиб. гос. ун-т},
		author={Чернова, НИ},
		journal={Новосибирск. 2007, 160 с},
		year={2007},
		langid={russian}
	}
	@article{williams2007partially,
		title={Partially observable Markov decision processes for spoken dialog systems},
		author={Williams, Jason D and Young, Steve},
		journal={Computer Speech \& Language},
		volume={21},
		number={2},
		pages={393--422},
		year={2007},
		publisher={Elsevier},
		langid={english}
	}

	@article{wills2020metrics,
		title={Metrics for graph comparison: A practitioner’s guide},
		author={Wills, Peter and Meyer, Fran{\c{c}}ois G},
		journal={Plos one},
		volume={15},
		number={2},
		pages={e0228728},
		year={2020},
		publisher={Public Library of Science San Francisco, CA USA},
		langid={english}
	}
	@article{donmezword,
		title={Word Vector Space for Text Classification and Prediction According to Author},
		author={D{\"o}nmez, {\.I}lknur and Pashaei, Elnaz and Pashaei, Elham},
		langid={english}
	}
	@article{нгок2012классификация,
		title={Классификация текстов на основе оценки семантической близости терминов},
		author={Нгок, Нгуен Ба and Тузовский, Анатолий Федорович},
		journal={Izvestiya Tomskogo Politekhnicheskogo Universiteta Inziniring Georesursov},
		volume={320},
		number={5},
		pages={43--48},
		year={2012},
		langid={russian}
	}
	@online{мухинмоделирование,
		author={Мухин, ОИ},
		title={Моделирование систем: учебник},
		year={2014},
		url = {http://stratum.ac.ru/education/textbooks/modelir/lection34.html},
		urldate = {2020-04-30},
		langid={russian}
	}
	
\end{filecontents}
%% Конец

%% Указываем файл с библиографией.
\addbibresource{bachelor-thesis.bib}

\begin{document}
	
	\studygroup{M3437}
	\title{Разработка алгоритмов работы с формальной моделью диалогов, представленных в виде графов}
	\author{Савон Юлия Константиновна}{Савон Ю.К.}
	\supervisor{Ульянцев Владимир Игоревич}{Ульянцев В.И.}{к.т.н.}{доцент факультета информационных технологий и программирования Университета ИТМО}
	\publishyear{2020}
	%% Дата выдачи задания. Можно не указывать, тогда надо будет заполнить от руки.
	\startdate{01}{сентября}{2019}
	%% Срок сдачи студентом работы. Можно не указывать, тогда надо будет заполнить от руки.
	\finishdate{10}{июня}{2020}
	%% Дата защиты. Можно не указывать, тогда надо будет заполнить от руки.
	\defencedate{26}{июня}{2020}
	
	\addconsultant{Ступаков И.М.}{канд. тех. наук, доцент}
	
	\secretary{Павлова О.Н.}
	
	%% Задание
	%%% Техническое задание и исходные данные к работе
	\technicalspec{Требуется провести исследование и разработать набор алгоритмов для выявления отвлечений в графовой модели для голосовой диалоговой системы.
		Алгоритм принимает набор диалогов, в размере нескольких тысяч. Предварительно выстроенный граф и кластеризацию для фраз оператора. 
		
		На выходе ожидается получить набор отвлечений и перестроенный граф. В качестве метрики качества будет использоваться сравнение с уже существующими графами, которые создавались вручную.}
	
	%%% Содержание выпускной квалификационной работы (перечень подлежащих разработке вопросов)
	\plannedcontents{Пояснительная записка должна описывать предметную область диалогов представленных в виде графов. Так же формулировать цель и задачу выделения отвлечений, содержать описание алгоритмов их поиска. Должны быть описаны сложности и методы их разрешения, если они возникали. Кроме того должны быть приведены примеры работы алгоритмов и сравнение с существующими решениями. Кроме того пояснительная записка должна содержать описания задач из смежных областей и их то, как эти задачи связны с задачей решаемой в работе.}%TODO добавить какие конкретно смежные области
	
	%%% Исходные материалы и пособия 
	\plannedsources{\begin{enumerate}
			\item Среда разработки Visial Studio Code;
			\item ГОСТ 7.32--2001 <<Система стандартов по информации, библиотечному и издательскому делу. Отчет о научно-исследовательской работе. Структура и правила оформления>>.
	\end{enumerate}}
	
	%%% Цель исследования
	\researchaim{Разработа алгоритма выделяющего отвлечения в диалоге, представленном в виде графа.}
	
	%%% Задачи, решаемые в ВКР
	\researchtargets{\begin{enumerate}
			\item Разработать алгоритмы выделения отвлечий;
			\item Реализовать описанные алгоритмы;
			\item Перестроить граф в соответствии с используемой моделью в компании;
			\item Проанализировать результаты работы алгоритмов;
			\item Интегрировать разработки в инфраструктуру компании.
	\end{enumerate}}
	
	%%% Использование современных пакетов компьютерных программ и технологий
	\addadvancedsoftware{Интегрированная среда разработки \texttt{PyCharm}}{Глава ~\ref{algorithms}}
	\addadvancedsoftware{Программное обеспечение для автоматизации развертывания и управления приложениями в средах с поддержкой контейнеризации \texttt{Docker}}{}
	\addadvancedsoftware{Распределённая система контроля версий \texttt{Git}}{Глава ~\ref{algorithms}}
	
	%%% Краткая характеристика полученных результатов 
	\researchsummary{}
	
	%%% Гранты, полученные при выполнении работы 
	\researchfunding{}
	
	%%% Наличие публикаций и выступлений на конференциях по теме выпускной работы
	\researchpublications{По теме этой работы был сделан доклад на Конгрессе Молодых Ученых.
		%\begin{refsection}
		%%Однако покажу, как можно ссылаться на свои публикации из списка литературы:
		%%\nocite{example-english, example-russian}
		%%\printannobibliography
		%\end{refsection}
	}
	
	%% Эта команда генерирует титульный лист и аннотацию.
	\maketitle{Бакалавр}
	
	%% Оглавление
	\tableofcontents
	
	%% Макрос для введения. Совместим со старым стилевиком.
	\startprefacepage
	
	Эта работа посвящена исследованию в области диалоговых систем.
	
	Диалоговая система -- алгоритм, который умеет принимать участие в диалоге на естественном языке и использует правила общения между людьми.
	
	В качестве примера диалоговых систем можно привести: 
	\begin{itemize}
		\item чат-боты
		\item голосовые помощники
		\item автоответчики в колл-центрах
	\end{itemize}\hskip1em

	Такие диалоговые системы могут быть как довольно простыми (например чат-бот отвечающий на заранее известный набор команд), так и сложными (например бот, отвечающий на вопрос на естественном языке и в качестве ответа возвращающий некоторую информацию из базы знаний).
	
	В последнее время набрали популярность технологии распознования и генерации речи, которые позволили создавать диалоговые системы, ведущие голосовой разговор. Данная работа рассматривает алгоритмы именно для голосовых диалогов. Пример решения такой диалоговой системы можно рассмотреть в статье ~\cite{williams2007partially}.
	
	Такие звонки с одной стороны должны быть не отличимы от звонков человека, с другой они должны придерживаться некоторого сценария.
	
	\textbf{Сценарий диалога с оператором} — некоторый алгоритм, предоставленный человеку, который звонит по некоторому набору номеров (либо же принимает входящий звонок или общается посредством программного обеспечения для аудиосвязи). Целью сценария обычно является получить или донести до клиента информацию. 
	
	Несмотря на то, что под сценарием диалога понимается некоторый алгоритм, необходимо понимать что для человека и диалоговой системы это принципиально разные сущности. Между скриптом\footnote{Здесь и далее в тексте \textbf{скрипт} и \textbf{сценарий} будут использоваться как синонимы} и алгоритмом, с точки зрения набора действий для машины есть большая разница. 
	
	Для человека это скорее структурированный список вопросов которые он должен задать и некоторая дополнительная база знаний с ответами на нестандартные вопросы. Кроме того человек может помнить некоторые факты и выдавать их дополнительно в зависимости от контекста. Он сам умеет обрабатывать ситуации, такие как отвлечение от основных вопросов или переспрашивание.
	
	Для скрипта же, любую реакцию надо прописывать, все возможные данные хранить и обновлять. Кроме того есть требование поддерживать этот скрипт доступным для восприятия человеком (например лингвистом), поскольку возникает необходимость в ручном анализе и редактировании. В данном случае такой скрипт будет представлен в виде графа с дополнительной информацией.
	
	\textbf{Голосовая диалоговая система} — программа, которая используя сценарий умеет проводить диалог с клиентом, интерпретировать и записывать  информацию полученную от клиента, а так же состояния завершенного разговора. Кроме того она умеет отвечать на заранее прописанный в скрипте набор вопросов и возвращаться обратно к диалогу.
	
	На данный момент существуют графы для диалогов, которые создаются вручную. Но писать их долго, а продумывать все важные случаи реакций сложно и трудоёмко. 
	
	Кроме того хочется иметь возможность усложнять вариативность диалогов. В связи с этим, ставится глобальная задача по созданию графа из набора проведенных диалогов. 
	
	Достаточно часто возникает ситуация, когда некоторый общий вопрос может возникнуть в любом месте диалога (например <<А что это за компания?>>). Таким образом было решено отделить их в отдельные подграфы и сделать возможность переходить в них при некоторых условиях из каждой вершины. В дальнейшем мы будем называть такие случаи \textbf{отвлечениями}.
	
	В работе будут рассмотрены различные алгоритмы автоматического поиска таких отвлечений.
	
	%% Начало содержательной части.
	\chapter{Обзор диалоговой модели}
	\section{Описание постановки задачи поиска отвлечений в диалговой модели графа}
	Глобальная задача, состоит в следующем: необходимо по набору диалогов восстановить диалоговую систему.
	
	Диалоговая система в данном случае представлена в виде графа, но так же существуют и другие представления.
	
	Целью данной работы ставится найти отвлечения в восстановленном графе.
	
	На данный момент кроме восстанавливаемой нами модели есть графы который составляется вручную. В этом графе вершинами являются кластеры фраз диалоговой системы, а рёбрами фразы человека. То есть при ответах человека происходит переход в разные новые вершины.
	
	Особенностями данной структуры, которые важно отметить, является то, что помимо обычных переходов существуют так же скрытые переходы, которые по умолчанию могут встретиться в любом месте. В качестве примера можно привести вопрос: <<А какую компанию вы представляете?>>. При звонке люди могут задать этот вопрос не сразу.
	
	Для того, чтобы не рассматривать каждый такой случай при переходе из каждой вершины, выделяются $\textbf{отвлечения}$. 
	
	$\textbf{Отвлечение}$ - вопрос, который может быть задан в любом месте диалога. Кроме того так же к одному из подтипу отвлечений относятся случаи, когда оператор не услышал фразу или вопрос и вынужден переспрашивать. В зависимости от модели это может выделяться в специальную сущность или являться отвлечением.
	
	В задаче восстанавления будет использоваться несколько другой граф. В нём вершинами будут являться кластеры и фраз оператора, и фраз человека. А ребрами последовательные пары фраз из кластеров в диалоге.
	
	\section{Анализ задачи выделения отвлечений}
	На вход подаётся набор диалогов по которым нужно получить граф для диалоговой системы, который бы мог проводить аналогичные диалоги.
	
	Граф, если получать его путём обычной кластеризации операторских фраз, получается очень громоздким. В нём плохо видно структуру, его сложно анализировать.
	
	Поскольку конечной целью является построить автомат аналогичный тому, что работает в продуктовой части команды, то появляется требование привести его в состояние, когда его можно изучать вручную. 
	
	То есть так же как и в графе создаваемом вручную, появляется необходимость выделить отвлечения. В этом случае его структура становится более удобной для изучения. Его можно использовать как вспомогательный инструмент. 
	
	Такие выделения отвлечений позволяют грамотно обрабатывать сценарии, которых не было в изначальном наборе диалогов. Если такие отвлечения не выделить, то в случае вопроса, не предусмотренного в этом месте диалоговая система либо ответит невпопад, либо зависнет.
	
	Необходима хорошая кластеризация текстов, поскольку любой алгоритм выделения отвлечений так или иначе будет опираться на эту кластеризацию. При таких кластеризациях полезно учитывать имеющуюся информацию, то есть фразы до текущей и после.
	
	
	\section{Постановка задачи}
	В связи с описаной выше проблемой громоздкости графа, появляется необходимость выделить отвлечения, которые соответственно могли бы встретиться в любом месте.
	
	В случае, когда диалог проводит оператор вопросы-отвлечения нет необходимости расписывать, но в отличие от оператора диалоговой системе нужен чёткий скрипт, который бы обрабатывал все возможные случаи.
	
	Необходимо выделить отвлечения и перестроить граф таким образом, чтобы отвлечения выделились в отдельный подграф, куда можно было бы перейти из любого места диалога. Такой граф будет покрывать большее количество диалогов. Кроме того, и сам граф, и отвлечения становится проще анализировать при необходимости вручную.
	
	\section{Выводы по первой главе}
	Рассмотрена предметная область графовой структуры диалогов. Разобрана структура продуктового графа и структура графа для восстанавливаемой модели. Проведён анализ задачи восстановления графа. Поставлена задача выделения отвлечений. 
	
	\chapter{Теоретическая часть}
	\section{Задача выделения отвлечений}
	Поскольку граф на данном этапе всё ещё перестраивается, то информация о произнесенных человеком фразах является полезной, так как содержит в себе контекст. Поэтому мы оставляем фразы человека в качестве вершин.
	
	Нужно понимать, что изначально кластеризация проводилась только по фразам оператора. Фразы вершин же были разделены на группы, где для каждой группы совпадала предыдущая и последующая вершины оператора. И уже внутри этих групп бились на некоторые подгруппы.
	
	Рассмотрим два подхода в решении задачи выделения отвлечений:
	
	\begin{itemize}
		\item Первый подход заключается в том, чтобы выделить вершины, в которые идёт много рёбер. Порог считается функцией от количества кластеров на которые бъются фразы оператора.
		
		Мы предполагаем, что поскольку отвлечение встречается в разных местах, то и рёбра будут идти в него из множества различных вершин. Такая гипотеза является хорошей, поскольку в обычном графе в вершину обычно приходит одна или две ветки, в случае же отвлечения их должно быть много, или же оно встречается крайне редко.
		
		\item В качестве другого подхода можно выделить циклы и сказать, что вершина следующая в диалоге за вершиной повторения с некоторой вероятностью будет являться началом отвечения.
		
		Здесь мы пользуемся наблюдением, что после отвлечения на стронний вопрос, оператор зачастую повторяет ту же или схожую фразу для возвращения в сценарий. Более того, эта идея используется в графе, который реализован для реального окружения. Там диалоговая система так же повторяет фразу, её сокращенную версию или её иную формулировку, которую произносил, перед тем, как перейти в отвлечение.
	\end{itemize}\hskip1em
	
	Поскольку подходы используют разные идеи их так же имеет смысл комбинировать и использовать данные полученные в обоих подходах.
	
	\section{Соответствие поставленным требованиям}
	Такие алгоритмы позволят найти для диалогов которые были проведены с системой, отвлечения, и сопоставить их с выделенными лингвистами вручную для графа.
	
	\chapter{Описание алгоритмов поиска отвлечений и объединения кластеров}
	\label{algorithms}
	\section{Подход поиска отвлечений с большим количеством рёбер входящих в вершину}
	Выбираются вершины, в которые входит много ребер. Для значений размеров кластеров в интервале от двенадцати до пятнадцати был выбран параметр три. При увеличении количества кластеров соответственно должен увеличиваться и порог.
	
	В некоторых случаях отвлечения не ограничиваются одной вершиной. В связи с этим появляется необходимость определить, где заканчивается то или иное отвлечение, и где соответственно оператору необходимо вернуться в вершину с которой он в это отвлечение ушёл. Для этого предположим следующую гипотезу -- если в вершину мы можем попасть только пройдя через отвлечение, то это значит, что фраза является частью соответсвующего отвлечения. 
	
	Для того, чтобы найти соответсвующий хвост для отвлечения используем следующий алгоритм: заблокируем вершину и рассмотрим все вершины, достижимые из вершины старта. Важно так же помнить о возможности того, что в кластерах могут быть допущены небольшие ошибки, поэтому если почти весь кластер недостижим после блокировки, то он так же входит в отвлечение.
	
	Ниже представлен псевдокод функции поиска таких хвостов для отвлечений:
	
	\begin{algorithmic}
	\Function{Digration finder}{$graph, node, dialogs$}
	\For{$dialog \in dialogs$}
		\State $flag\gets True$
		\For{$msg \in dialog$}
		\State{$msgs[msg.cluster]++$}
		\If {$(msg.cluster == node.cluster) and flag$ }
		\State{$achieved.add(msg.cluster)$}
		\State{$achieved_msgs[msg.cluster].add(msg)$}
		\Else
		\State {$flag \gets False$}
		\EndIf
		\EndFor
	\EndFor
	\For{$cluster \in graph.clusters$}
		\If {$cluster not in achieved$}
		\State{$diression_clusters.add(cluster)$}
		\Else
			\If {$achieved_msgs[cluster]/msgs[cluster] > 0.9$}
			\State{$diression_clusters.add(cluster)$}
			\EndIf
		\EndIf
	\EndFor
	\EndFunction
\end{algorithmic}	
	
	Во время тестирования на реальных диалогов человека с человеком была выявлена важная особенность. На работу алгоритма очень сильно влияет качество кластеризации. Поскольку фразы в голосовых диалогах не всегда верно переводятся в текст, сами фразы сравнительно короткие. А в случае людей-операторов ещё и очень вариативные, то кластеризация оказалась очень некачественной.
	
	\section{Подход поиска отвлечений с поиском циклов}
	Поскольку говорит на сторонние темы только человек, а оператор идёт по скрипту, то в подавляющем большинстве случаев после ответа на сторонний вопрос, оператор задаёт свой вопрос заново. В связи со спецификой человеческий диалогов можно выделить несколько полезных особенностей:
	
	\begin{itemize}
		\item Подавляющее большинство поддиалогов отвлечений достаточно короткие.
		\item Вопрос повторяет оператор, поэтому циклы можно искать с повторением только операторской вершины.
		\item Возможно появление отвлечения внутри отвлечения, поэтому необходимо найти оба.
	\end{itemize}\hskip1em
	
	Для решения особенности первого пункта было добавлено ограничение на расстояние между ними в диалоге. Оно должно быть не слишком велико, поскольку ясно что отвлечение бывает длинным очень редко, а иначе можно случайно выкинуть почти весь диалог.
	
	Проблема последнего пункта решается тем, что мы удаляем циклы по мере нахождения. Таким образом внутренний цикл будет удалён раньше внешнего.
	
	В этом случае в качестве потенциальных отвлечений мы выбираем вершины человеческих фраз которые первые следуют после начала цикла. После перевода графа в продуктовый режим у нас эти вершины станут рёбрами и таким образом в графе появятся рёбра-триггеры, которые будут перенаправлять ход диалога в вершину-отвлечение.
	
	Ниже находится псевдокод для поиска одного цикла:
	
	\begin{algorithmic}
		\Function{Remove cycles}{$dialog$}
		\For{$msg \in dialog$}
		\State $msg\_num++$
		\If {$(last\_msg[msg.cluster] - msg\_num) <= 5$ }
		\State {$cycle\_end \gets last\_msg[msg.cluster]$}
		\State{$dialog.remove\_cluster(cycle\_start, msg\_num)$}
		\EndIf
		\EndFor
		\EndFunction
	\end{algorithmic}
	
	
	\section{Выборка хороших кластеров}
	В качестве решения проблемы некачественной кластеризации было предложено использовать данные из фраз человека. До этого для всех фраз человека между двумя фразами оператора, они кластеризировались и никак не использовались. 
	
	Было решено кластеризировать тексты пользователей. Но поскольку как описывалось выше, кластеризация не достаточно хорошая, то необходимо было отсеять плохие кластеры во избежание каскадных ошибок.
	
	Для этого использовалось попарное сравнение фраз внутри каждого кластера. Для этого сравнивались наборы слов внутри фразы с весами. Если точность превышала порог 0.5, то пара считалась хорошей.
	
	Константа 0.5 была выведена эмперически. Для большего значения в кластре начинало содержаться большое количество фраз разных по смыслу. 
	
	Проверять все пары оказалось очень долго $O(n^2)$, а в предыдущей части восставновления все операции имели ассимтотику не более чем $O(n \log n)$, то получилось так, что эта часть занимала значительно больше половины времени от всего восстановления графа. 
	
	Тогда было решено для каждого кластера брать случайную выборку, равная утроенному размеру кластера, ассимптотически это занимало уже $O(n)$. В силу достаточно больших размеров кластеров (размер их для основной массы данных состовляет несколько сотен фраз нескольких сотен фраз), статистически показывало те же результаты, что и полная выборка.
	
	\begin{prop}
		При размере диалога от 40 фраз необходимое количество экспериментов для попадания в доверительный интервал $Q=0.95$ и доверительной вероятности\footnote{Определение доверительного интервала можно изучить здесь.\cite{чернова2007теория}} $\varepsilon=0.1$ достаточно 3n экспериментов.
	\end{prop}
	\begin{proof}
		Значение $p=0,5$ -- наихудшее, в том смысле, что для него вероятность порогового отклонения превысит выбранное значение $\varepsilon$, при наибольшем количестве экспериментов. Таким образом достаточно доказать утверждение для него. Для такого случая результат равен 96, причём вне зависимости от размера возможных исходов, т.е. вне зависимости от размера кластера. Эксперименты рассчитанные для разных значений приведены в учебнике.\cite{мухинмоделирование}
	\end{proof}
	
	Таким образом для более маленьких кластеров можно рассчитать эти значения перебрав все пары полностью, а для больших кластеров такого количества экспериментов будет достаточно.
	
	Ниже приведён псевдокод для функции, считающей метрику для вершин с большим количеством фраз:
	
	\begin{algorithmic}
		\Function{IsGoodCluster}{$msgs$}
			\State $num\_of\_comparings \gets 3 \cdot msgs.size()$
			\For{$(msg1, msg2) \in msgs.getPairs(num\_of\_comparings)$}
				\State $good\_pairs += msg\_compare(msg1, msg2)$
			\EndFor
			\State $cluster\_threshold \gets 0.5$
			\State \Return{$good\_pairs$ / $num\_of\_comparings$ >= $cluster\_threshold$}
		\EndFunction
	\end{algorithmic}

	Функция $msg\_compare(msg1, msg2)$ отвечает за сравнение двух сообщений.
	\section{Функция сравнения сообщений}
	Для алгоритма выше необходима функция сравнения двух сообщений. Для неё должны быть выполнены следующие условия:
	\begin{itemize}
		\item Функция должна быть бинарной. $True$ -- в случае схожести сообщений, $False$ -- иначе.
		\item Функция должна работать за $O(1)$, при условии, что длинну сообщений мы так же принимаем за $O(1)$.
	\end{itemize}\hskip1em

	Второе условие необходимо, поскольку в противном случае при среднем размере групп сообщений от нескольких сотен разница во времени будет в разы увеличиваться.
	
	В качестве алгоритма для сравнения сообщений был выбран следующий: берутся наборы слов в виде сетов и пересекаются с учётом весов слов. Это значение записываем в числитель. В качестве знаменателя берём объединение наборов слов с теми же коэффициентами слов и соответсвующими количественными коэффициентами и записываем в знаменатель.
	
	Полученная дробь должна превышать некоторый порог, который ищется вручную.
	
	В качестве альтернативных вариантов функций могут быть использованы следующие:
	\begin{itemize}
		\item Сравнение фраз на основе семантической близости. Об этом алгоритме можно прочитать в следующей статье.\cite{нгок2012классификация}
		\item Сравнение фраз с помощью эмбеддингов и на основе косинусного расстояния. Об этом подходе можно почитать здесь.\cite{donmezword}
	\end{itemize}\hskip1em
	Все перечисленные и описанные функции подходят под перечень изначальных условий, поскольку функции возвращающие не целые значния в диапазоне от 0 до 1 можно превратить вступенчатую, сделав её бинарной. Все они работают за ассимптотически необходимое время.
			
	\section{Слияние кластеров операторских сообщений}
	Изначальный алгоритм, который создавал вершины операторов предполагал точный выбор количества кластеров. Новое решение предполагает избыточное разбиение на кластеры. Поскольку количество кластеров на которые разделяются операторские сообщения можно контролировать вручную, это регулируется достаточно просто.
	
	После такого разбиения выделятся кластеры, фразы в которых максимально похожи между собой, в таком разбиении будет меньше ошибок  вида -- в одном кластере содержательно разные сообщения.
	
	Далее после выбора хороших человеческих вершин, для каждой операторской вершины рассматриваются все другие операторские вершины. Далее было несколько версий метрик для сравнения соседних вершин.
	
	В первой версии рассматривались все соседские вершины. Они не делились группы по положению до или после и соответсвенно это было недостаточно хорошим решением.
	
	Во второй версии были выбирались все вершины до, исходя из предположения, что они будут больше коррелировать с содержанием операторских вершин и не будет проблемы с тем, что не учтён порядок.
	
	\section{Оценка для сравнения графов}
	В качестве верной модели использовалась модель написанная вручную. Модель хранится в формате $json$ и в ней фразы человека соответственно являются условиями перехода.
	
	Для того, чтобы можно было сравнивать текущую модель и изначальную, необходимо было перевести вторую модель к формату первой. 
	
	Здесь стоит напомнить, что в восстанавливаемой модели кластеры человеческих фраз так же являлись вершинами. Таким образом для того, чтобы была возможность перевести их в рёбра и соответственно сопоставить изначальному графу, для каждой вершины с человеческими кластерами должны были быть верны следующие условия:
	\begin{itemize}
		\item У вершины должна быть ровно одна предыдущая, причём эта вершина должна быть вершиной операторских фраз.
		\item Последующая вершина должна быть вершиной обязана так же быть операторской и единственной для данной.
		\item Ни одна из набора фраз данного кластера не должна совпадать с фразами из кластеров, в которые ведут рёбра из предыдущей операторской вершины.
	\end{itemize}\hskip1em

	Проверив, что все необходимые условия соблюдены, можно преобразовывать граф, выделяя отвлечения следующим образом:
	\begin{itemize}
		\item Каждая вершина новой модели сопостовлялась одной одной изначальной. Сопоставление проводилось путём сравнения произносимой фразы.
		\item Вершины фраз человека были выделены в группы, каждая группа относилась к одному ребру и являлась будующим набором исходящих рёбер.
		\item Технические вершины в изначальном графе игнорировались, но учитывалось их место в последовательности модели.
		\item Сравнивались наборы вершин отвлечения в изначальном графе и в полученном.
		\item При создании метрики для графа была использована статья ~\cite{wills2020metrics}
	\end{itemize}\hskip1em
	
	
	\chapter{Результаты экспериментов}
	\section{Используемые данные}
	В качестве данных использовалось два принципиально разных типа наборов диалогов. Первые проводились уже с существующим скриптом. Второй тип, это данные диалогов человека с человеком.
	
	1.Особенность первого заключается в том, что там легко кластеризовать фразы оператора, так как они произносятся всегда одинаково, за исключением вариаций для коротких вариантов. 
	
	Но необходимо понимать, что случаи повторения фразы имеют другие вершины соседей поскольку расчитаны на специфичные случаи. Такие объединения были полезны для алгоритма поиска циклов, но находить их было сложно в силу того, что они явным образом не попадали под условия. Так же можно было выявить сликом заниженные коэффициенты, при слиянии фраз, которые не являлись одинаковыми. 
	
	Важным вариантом использования таких данных являлась возможность  перевести полученный граф в тот же формат и сравнить полученный результат с оригиналом.
	
	2.Особенности второго соответсвенно следующие: во первых там говорят разные операторы и у них разный стиль подачи одних и тех же данных. Во вторых диалоги более сложные и зачастую отходят от скрипта. В третьих люди решают более сложные вопросы и умеют давать ответы на не предусмотренные скриптом вопросы. На этот вариант данных стоит ориентироваться, но в связи с отсутствием оригинального скрипта в удобном формате напрямую сравнить полученный результат представляется возможным только вручную.
	
	В обоих случаях есть сложности с переводом речи людей в текст, поэтому иногда даже рассматривая текст диалога вручную нельзя понять что человек имел ввиду.
	
	Для всех датасетов первого типа соответсвенно существуют файлы, содержащие в себе оригинальный граф, который принимается за верный. Все данные сериализованы в формате \texttt{JSON}. 
	
	На Рисунке 1 представлен результат полученного после восстановления графа:
	
	\begin{figure}[h!]
		\center{\includegraphics[scale=0.45]{Graph_sample.png}}
		\caption{Восстановленный граф}
		\label{fig:image}
	\end{figure}

	В этой модели голубым цветом обозначены операторские вершины, синим соответсвенно человеческие. Крого того, для удобства анализа выделены две фиктивные вершины: стартовая и вершина окочания диалогов. Вдальнейшем для приведённых данных они в расчёт не брались.
	
	\section{Результаты улучшения кластеризации}
	Алгоритм вносит небольшие изменения и способен объединять некоторые одинаковые кластеры. 
	
	Основная сложность состояла в анализе, так как для данных из разговоров с искуственным интелектом кластеризация фраз оператора изначально была очень хорошей в силу того, что фразы повторялись. Для случаев разговоров человека с человеком анализ результатов приходилось проводить вручную в силу отсутствия разметки данных.
	
	Были проведены исследования по влиянию параметров алгоритма на результат. В результате чего были выявлены следующие закономерности: 
	\begin{itemize}
	\item Пороговое значение схожести сообщений для каждого кластера должно варьироваться от 0.2 до 0.5. В этом промежутке в качестве пар схожих сообщений выбираются схожие пары сообщений. Для меньшего значения соответственно практически полностью одинаковые. Для большего у них  появляется вариативность.
	\item Пороговое значение количества хороших пар в кластере должно варьироваться так от 0.25 до 0.5. Для больших значений в одном кластере начинают появляться наборы фраз несущие разный смысл.
	\end{itemize}\hskip1em

	Ниже, на Рисунке 2 представлены примеры различных значений промежутков порога для количества хороших пар в кластере:
	
	 \begin{figure}[H]
		\begin{subfigure}[c]{0.3\textwidth}
			\includegraphics[width=\textwidth]{Sample_0.3.eps}
			\caption{0.3}
		\end{subfigure}
		\begin{subfigure}[c]{0.3\textwidth}
			\includegraphics[width=\textwidth]{Sample_0.5.eps}
			\caption{0.5}
		\end{subfigure}
		\begin{subfigure}[c]{0.3\textwidth}
			\includegraphics[width=\textwidth]{Sample_0.6.eps}
			\caption{0.6}
		\end{subfigure}
		\caption{Различные значения пороговой функции количества хороших пар}
		\label{ris:image1}
	\end{figure}
	
	\section{Результаты работы алгоритма поиска отвлечений по рёбрам}
	Для данного алгоритма критично качество кластеризации и наличие небольшого количества выбросов. 
		
	В случае с данными из реальных диалогов зачастую не было видно правильно выделеных отвлечений из-за смешения кластеров и операторских и человеческих вершин.
		
	Для данных из диалогов с существующей диалоговой системой алгоритм находил все отвлечения и так же отмечал небольшое количество дополнительных вершины, которые отвлечениями не являются. Основная причина столь большого различия в том, что операторские фразы во втором случае кластеризуются практически идеально.
	
	\section{Результаты алгоритма поиск циклов}
	После того, как мы нашли циклы мы их удаляем, таким образом основной граф становится менее громоздким и его легче анализировать. Из особенностей реализации важно отметить, что удаляются не все циклы, а только размера не более чем 5. Рассмотрим пример следующего диалога:
	
	\textit{Оператор: Здравствуйте}
	
	\textit{Человек:  Ало}
	
	\textit{Оператор:  Меня зовут Даша, вы ***\footnote{Здесь и далее *** будут использоваться для обезличивания частей диалога, которые не содержат важных для алгоритма данных, но несут в себе персональную информацию или информацию о компаниях.}?}
	
	\textit{Человек:  *шуршание*\footnote{Здесь и далее *описание* для пропуска не содержательных частей с коротким описанием.}}
	
	\textit{Оператор:  Извините, я вас не расслышал, повторите пожалуйста}
	
	\textit{Человек:  Я говорю давайте задавайте}
	
	\textit{Оператор:  Вы сейчас ***?}
	
	\textit{Человек:  сейчас нет}
	
	\textit{Оператор:  Вы нашли ***?}
	
	\textit{Человек:  да}
	
	\textit{Оператор:  Убрать *** в архив?}
	
	\textit{Человек:  *неразборчивый текст*}
	
	\textit{Оператор:  Извините, я вас не расслышал, повторите пожалуйста}
	
	\textit{Человек:  ненадо пока убирать ***}
	
	\textit{Оператор:  Извините за беспокойство, всего доброго, до свидания}\\
	
	Если мы удалим все фразы между двумя просьбами повторить,то потеряем состояния, которые не являются отвлечениями.
	%вставить полноценный обезличенный пример и картинки со случаями, и код
		
	Ниже приведена Таблица 1, в ней видно как уменьшается размер графа при удалении циклов. Для каждого графа в первой строке соответсвенно записана информация до удаления циклов, во второй -- после:\\
	
	\begin{table}[H]
	\caption{Применение алгоритма удаления циклов}
	\begin{tabular}{|c|c|c|c|}
	\hline
	Номер датасета & размер & количество вершин & количество рёбер\\
	\hline
	1&10000 & 141 & 587\\%log_zar-ru_10000
	&		& 134 & 528\\ %12
	\hline
	2&661&71&194\\ %13 zar-ru-di
	 &   &67&179\\
	\hline
	3&1000&155&570\\ %12 log_alp_oper
	 &    &142&479\\
	\hline
	4&1086&98&283\\ %14 modul
	 &    &92&252\\
	\hline
	5&998&159&753\\
	 &   &142&631\\ %grep
	\hline
	6&5000&48&137\\ %13
	 &    &46&120\\
	\hline
	7&10000&88&296\\%logs modul
	 &     &87&293\\
	\hline
	8&10000&112&515\\%logs alfa
	 &     &111&506\\
	\hline
	9&3325&161&1078\\
	 &    &154&955\\ %17
	\hline
	10&10000&116&473\\
	  &     &115&457\\ %15
	\hline
	11&588&122&366\\
	  &   &115&340\\ %15 alpha dial
	\hline
	
	\end{tabular}
	\end{table}

	Среди этих датасетов есть 2 принципиально разных типа:
	
	Первый тип -- \textbf{оператор + человек}, эти датасеты нам предоставили компании и в них человек придерживается некоторого скрипта, но заметно от него отклоняется, поэтому при меньших размерах порядок вершин в них такой же. К этому типу относятся соответственно датасеты 2, 4, 5, 9, 11.
	
	Второй тип -- \textbf{искуственный интелект + человек}, эти датасеты были собраны соответственно компанией при звонках со скриптами написанными вручную. К этому типу соответственно относятся 1, 3, 6, 7, 8, 10.
	
	В обоих типах при увеличении размера датасета увеличивается количество вершин. Важно отметить, что большинство из вершин, это ответы человека, количество же операторских вершин примерно равно 15. Для случая диалогов человека с человеком размеры графа могут быть изначально больше, это объясняется тем, что в нём больше вариативность фраз.
	
	Вырезанные ребра и вершины соответственно отделяются и становится проще анализировать граф.
	
	Если рассмотреть какие вершины из операторских попадают в циклы, то хорошо видно тенденцию того, что есть несколько вершин у которых большое количество ответов попадает в циклы. Некоторые такие вершины, как можно заметить исчезают вообще. Для остальных можно подобрать пороговое значение при котором можно будет считать, что вершина является триггером отвлечения.
	\section{Программная реализация}
	Предложенные алгоритмы были реализованы на языке \texttt{Python} с использованием интегрированной среды разработки \texttt{Pycharm}. Кроме того использовался текстовый редактор \texttt{Visual Studio Code} с внутренним плагином для визуализации графов описанных в формате \texttt{JSON}.
	
	Компания использует приватный \texttt{Git}-репозиторий, находящийся на хостинге \texttt{Gitlab}. Для удобства локальной разработки приложение запускалось в \texttt{Docker}-контейнере.
	
	\startconclusionpage{}
	В ходе выполнения работы была рассмотрена задача выделения отвлечений в графовой модели для голосовой диалоговой системы. Для её решения были разработаны и написаны алгоритмы основанные на особенностях разговоров оператора с человеком. Были учтены особенности существующей модели графовых диалогов и данные полученные при её использовании.
	
	Были написаны алгоритмы выделения циклов и поиска отвлечений по рёбрам. Эти алгоритмы позволяют выделить значительное количество отвлечений и уменьшают размер основного графа. Кроме того в ходе разработки стало ясно, что алгоритмы очень чувствительны к кластеризации и возникла необходимость улучшить её качество. Для чего был разработан алгоритм на основе данных о соседних фразах.
	
	Поскольку работа является частью большего проекта. То интеграция в реальное окружение запланирована по завершению всех частей проекта. Разработка должна будет автоматизировать часть рабочих процессов.
	
	Одно из возможных направлений развития работы, использовать информацию о пользователе в диалоге, сделав его таким образом более естественным. Так же существует возможность выделить некоторые общие отвлечения для всех диалогов, получая таким образом возможность предсказывать отвлечения в виде подсказок.
	\printmainbibliography
	
	\includepdf[pages=1]{KMU_diploma.pdf}
\end{document}
